{"/":{"title":"","content":"906bc906의 Obsidian Vault. Quartz로 빌드되었으며 Github Pages로 호스팅 중.\n\n[메인 Main](note/메인%20Main.md)","lastmodified":"2022-10-06T14:49:07.154768861Z","tags":null},"/README":{"title":"","content":"이 리포지토리는 Obsidian으로 작성되었습니다. 다른 마크다운 에디터에서 불러올 경우 Obsidian 플러그인 관련 신택스들이 정상적으로 동작하지 않습니다.\n\n","lastmodified":"2022-10-06T14:49:07.154768861Z","tags":null},"/note/%EB%8B%A4-%EC%9D%BD%EC%9D%80-%EC%B1%85-done":{"title":"","content":"# 다 읽은 책 done\n\u003c!--Basic Template V0.0.2 Start --\u003e\n```dataview\nTABLE WITHOUT ID  file.link AS title, tags\nFROM -\"templates\"\nSORT file.mtime, tags desc\nWHERE contains(tags, [[]])\n```\n\u003c!--Basic Template V0.0.2 End --\u003e\n[tags::[[책 Book]]]","lastmodified":"2022-10-06T14:49:07.154768861Z","tags":null},"/note/%EB%A6%AC%EB%88%85%EC%8A%A4%EC%99%80-%EC%9C%88%EB%8F%84%EC%9A%B0-SMB%EB%A1%9C-GIT-%EA%B3%B5%EC%9C%A0-%EC%8B%9C-%EA%B2%AA%EB%8A%94-%EB%AC%B8%EC%A0%9C":{"title":"","content":"# 리눅스와 윈도우, SMB로 GIT 공유 시 겪는 문제\n\u003c!--Basic Template V0.0.2 Start --\u003e\n```dataview\nTABLE WITHOUT ID  file.link AS title, tags\nFROM -\"templates\"\nSORT file.mtime, tags desc\nWHERE contains(tags, [[]])\n```\n\u003c!--Basic Template V0.0.2 End --\u003e\n[tags::[[git 깃]]]\n\n컴퓨터는 윈도우, 노트북은 리눅스를 사용하고 있고, 간이NAS에 repo를 두고 OS를 번갈아가면서 쓰고 있는데 좀 많은 문제를 겪고 있다.\n\n## safe directory\n\n오류 뜨는 거 그대로 허용해준다.\n\n## 개행 문자 문제\n\n[git 에서 CRLF 개행 문자 차이로 인한 문제 해결하기](https://www.lesstif.com/gitbook/git-crlf-20776404.html)\n\n윈도우는 CRLF, 유닉스와 맥은 LF를 사용하면서 이로 인한 diff 가 엄청나게 발생한다.\n\n윈도우에서 LF로 설정한다.\n\n```bash\ngit config --global core.eol lf\n```\n\n## 파일 모드 문제\n\n거의 대부분의 파일이 100755 100644 모드 문제를 겪고 있었다.\n\nhttps://codecooking.tistory.com/113\n\n바람직한 해결법은 아니지만 지금 당장 해결하기 위해서 repo에서 filemode를 비활성화했음.","lastmodified":"2022-10-06T14:49:07.154768861Z","tags":null},"/note/%EB%A6%AC%EB%88%85%EC%8A%A4-%EB%94%94%EC%8A%A4%ED%94%8C%EB%A0%88%EC%9D%B4-%EC%83%89%EC%98%A8%EB%8F%84-%EC%A1%B0%EC%A0%88":{"title":"","content":"# 리눅스 디스플레이 색온도 조절\n## scr\n### 설치\n`sudo apt install sct`\n\n### 사용\n`sct [temperature]`\n1000 - 10000 사이에서 사용, 기본값은 6500\n\n### 리셋\n`scr`\n\n## gnome\n![[Pasted image 20221005001456.png]]\nsettings -\u003e display -\u003e night mode\n","lastmodified":"2022-10-06T14:49:07.154768861Z","tags":null},"/note/%EB%A6%AC%EB%88%85%EC%8A%A4-OS-%EC%82%AC%EC%9A%A9":{"title":"","content":"# 리눅스 (OS 사용)\n\u003c!--Basic Template V0.0.2 Start --\u003e\n```dataview\nTABLE WITHOUT ID  file.link AS title, tags\nFROM -\"templates\"\nSORT file.mtime, tags desc\nWHERE contains(tags, [[]])\n```\n\u003c!--Basic Template V0.0.2 End --\u003e\n[tags::]\n\n- [[리눅스 디스플레이 색온도 조절]]","lastmodified":"2022-10-06T14:49:07.154768861Z","tags":null},"/note/%EB%A9%94%EC%9D%B8-Main":{"title":"","content":"# 메인 Main\n## To-do\n- [ ] Gitlab 크레덴셜 토큰으로 바꿀 것 (지금 평문 보관중임)\n- [ ] Github 토큰 권한 최소화하여 이관\n## Public\n- [[소프트웨어 개발 Software development]]\n- [[건강]]\n## Private\n\n**Pinned list**\n- [[모든 노트 All notes]]\n- [[태그 없는 노트 no tag]]\n\n![[Recentrly Modified]]\n\n```dataview\nTABLE tags\nFROM -\"templates\"\nSORT file.mtime desc\nWHERE contains(tags, [[to do]])\n```","lastmodified":"2022-10-06T14:49:07.154768861Z","tags":null},"/note/%EB%AA%A8%EB%93%A0-%EB%85%B8%ED%8A%B8-All-notes":{"title":"","content":"# 모든 노트 All notes\n```dataview\nTABLE WITHOUT ID file.link as \"Recently Modified\", choice(none(tag),\"_\",join(tag)) as tag\nSORT file.mtime desc\n```\n[tag::[[메인 Main]]]","lastmodified":"2022-10-06T14:49:07.154768861Z","tags":null},"/note/%EC%86%8C%ED%94%84%ED%8A%B8%EC%9B%A8%EC%96%B4-%EA%B0%9C%EB%B0%9C-Software-development":{"title":"","content":"# 소프트웨어 개발 Software development\n## 개발자\n- [[프로그래밍]]\n- [[컴퓨터 과학]]\n- [[알고리즘]]\n## 취업 준비","lastmodified":"2022-10-06T14:49:07.154768861Z","tags":null},"/note/%EC%95%84%EC%A7%81-%EC%95%88-%EC%9D%BD%EC%9D%80-%EC%B1%85-not-read-yet":{"title":"","content":"# 아직 안 읽은 책 not read yet\n\u003c!--Basic Template V0.0.2 Start --\u003e\n```dataview\nTABLE WITHOUT ID  file.link AS title, tags\nFROM -\"templates\"\nSORT file.mtime, tags desc\nWHERE contains(tags, [[]])\n```\n\u003c!--Basic Template V0.0.2 End --\u003e\n[tags::[[책 Book]]]","lastmodified":"2022-10-06T14:49:07.154768861Z","tags":null},"/note/%EC%97%AC%EB%9F%AC-%EB%A7%88%ED%81%AC%EB%8B%A4%EC%9A%B4-%ED%8C%8C%EC%9D%BC%EC%9D%84-%ED%95%9C%EB%B2%88%EC%97%90-find-and-replace-%ED%95%98%EB%8A%94-%EB%B0%A9%EB%B2%95":{"title":"","content":"# 여러 마크다운 파일을 한번에 find and replace 하는 방법\n\u003c!--Basic Template V0.0.2 Start --\u003e\n```dataview\nTABLE WITHOUT ID  file.link AS title, tags\nFROM -\"templates\"\nSORT file.mtime, tags desc\nWHERE contains(tags, [[]])\n```\n\u003c!--Basic Template V0.0.2 End --\u003e\n[tags::[[obsidian 옵시디언]]]\n\nhttps://stackoverflow.com/questions/37346481/how-do-i-find-and-replace-all-occurrences-in-all-files-in-visual-studio-code\n\nObsidian에서는 현재 가능한 방법이 없어 VS code를 이용해야 한다.","lastmodified":"2022-10-06T14:49:07.154768861Z","tags":null},"/note/%EC%9B%B9-%EA%B0%9C%EB%B0%9C":{"title":"","content":"# 웹 개발\n## Basic\n- [[HTML]]\n- [[CSS]]\n- [[Javascript]]\n\n## Frontend\n- [[SolidJS]]\n## Backend\n- [[Express]]\n## Etc","lastmodified":"2022-10-06T14:49:07.154768861Z","tags":null},"/note/%EC%9D%98%EC%A1%B4%EC%84%B1-%EC%A3%BC%EC%9E%85-dependency-Injection":{"title":"","content":"# 의존성 주입 dependency Injection\n\u003c!--Basic Template V0.0.2 Start --\u003e\n```dataview\nTABLE WITHOUT ID  file.link AS title, tags\nFROM -\"templates\"\nSORT file.mtime, tags desc\nWHERE contains(tags, [[]])\n```\n\u003c!--Basic Template V0.0.2 End --\u003e\n[tags::[[to do]]]","lastmodified":"2022-10-06T14:49:07.154768861Z","tags":null},"/note/%EC%9D%BD%EA%B3%A0-%EC%9E%88%EB%8A%94-%EC%B1%85-reading":{"title":"","content":"# 읽고 있는 책 reading\n\u003c!--Basic Template V0.0.2 Start --\u003e\n```dataview\nTABLE WITHOUT ID  file.link AS title, tags\nFROM -\"templates\"\nSORT file.mtime, tags desc\nWHERE contains(tags, [[]])\n```\n\u003c!--Basic Template V0.0.2 End --\u003e\n[tags::[[책 Book]]]","lastmodified":"2022-10-06T14:49:07.154768861Z","tags":null},"/note/%EC%B1%85-Book":{"title":"","content":"# 책 Book\n\n=== multi-column-start: ID_y7xa\n```column-settings\nNumber of Columns: 3\nLargest Column: standard\nBorder: false\nshadow: false\n```\n\n[[아직 안 읽은 책 not read yet]]\n```dataview\nTABLE WITHOUT ID list(file.link, \"- \"+join(filter(tags, (x) =\u003e all(x != [[책 Book]], x != [[아직 안 읽은 책 not read yet]])))) as \"\"\nFROM -\"templates\"\nSORT file.mtime desc\nWHERE contains(tags, [[아직 안 읽은 책 not read yet]])\n```\n\n=== end-column ===\n\n[[읽고 있는 책 reading]]\n```dataview\nTABLE WITHOUT ID list(file.link, \"- \"+join(filter(tags, (x) =\u003e all(x != [[책 Book]], x != [[읽고 있는 책 reading]])))) as \"\"\nFROM -\"templates\"\nSORT file.mtime desc\nWHERE contains(tags, [[읽고 있는 책 reading]])\n```\n\n=== end-column ===\n\n[[다 읽은 책 done]]\n```dataview\nTABLE WITHOUT ID list(file.link, \"- \"+join(filter(tags, (x) =\u003e all(x != [[책 Book]], x != [[다 읽은 책 done]])))) as \"\"\nFROM -\"templates\"\nSORT file.mtime desc\nWHERE contains(tags, [[다 읽은 책 done]])\n```\n\n\n=== multi-column-end\n\n[tag::[[메인 Main]]]","lastmodified":"2022-10-06T14:49:07.154768861Z","tags":null},"/note/%ED%83%9C%EA%B7%B8-%EC%97%86%EB%8A%94-%EB%85%B8%ED%8A%B8-no-tag":{"title":"","content":"# 태그 없는 노트 no tag\n```dataview\nTABLE tags\nFROM -\"templates\"\nSORT file.mtime desc\nWHERE none(tags)\n```\n[tag::[[메인 Main]]]\n","lastmodified":"2022-10-06T14:49:07.154768861Z","tags":null},"/note/%ED%8A%B9%EC%A0%95-%EB%B8%8C%EB%9E%9C%EC%B9%98%EB%A7%8C-pull-%ED%95%98%EA%B8%B0":{"title":"","content":"# 특정 브랜치만 pull 하기\n\n\n\u003c!--Basic Template V0.0.2 Start --\u003e\n```dataview\nTABLE WITHOUT ID  file.link AS title, tags\nFROM -\"templates\"\nSORT file.mtime, tags desc\nWHERE contains(tags, [[]])\n```\n\u003c!--Basic Template V0.0.2 End --\u003e\n[tags::[[git 깃]]]\n\nTARGET DECK\n전체::개발::GIT\n\n---\n\n\u003c!--ankiQ--\u003e\n\norigin remote 로부터 specific branch 만 pull 하려면 어떻게 해야되는가?\n\n\u003c!--ankiA--\u003e\n\n`git pull origin specific`\n\n\u003c!--ankiE--\u003e\n\u003c!--ID: 1665034174803--\u003e\n","lastmodified":"2022-10-06T14:49:07.154768861Z","tags":null},"/note/%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%98%EB%B0%8D":{"title":"","content":"# 프로그래밍\n\u003c!--Basic Template V0.0.2 Start --\u003e\n```dataview\nTABLE WITHOUT ID  file.link AS title, tags\nFROM -\"templates\"\nSORT file.mtime, tags desc\nWHERE contains(tags, [[]])\n```\n\u003c!--Basic Template V0.0.2 End --\u003e\n[tags::]\n\n- [[웹 개발]]\n- [[리눅스 (OS 사용)]]\n- [[git 깃]]\n- [[github 깃헙]]","lastmodified":"2022-10-06T14:49:07.154768861Z","tags":null},"/note/%ED%94%BC%ED%86%A8%EB%A1%9C%EC%A7%80-%ED%94%BC%ED%8A%B8%EB%8B%88%EC%8A%A4-%EC%98%81%EC%96%91%ED%95%99":{"title":"","content":"# 피톨로지 피트니스 영양학\n\u003c!--Basic Template V0.0.2 Start --\u003e\n```dataview\nTABLE WITHOUT ID  file.link AS title, tags\nFROM -\"templates\"\nSORT file.mtime, tags desc\nWHERE contains(tags, [[]])\n```\n\u003c!--Basic Template V0.0.2 End --\u003e\n[tags::[[책 Book]], [[아직 안 읽은 책 not read yet]]]","lastmodified":"2022-10-06T14:49:07.154768861Z","tags":null},"/note/Bun":{"title":"","content":"# Bun\n\u003c!--Basic Template V0.0.2 Start --\u003e\n```dataview\nTABLE WITHOUT ID  file.link AS title, tags\nFROM -\"templates\"\nSORT file.mtime, tags desc\nWHERE contains(tags, [[]])\n```\n\u003c!--Basic Template V0.0.2 End --\u003e\n[tags::[[to do]]]","lastmodified":"2022-10-06T14:49:07.154768861Z","tags":null},"/note/EdgeDB":{"title":"","content":"# EdgeDB\n\u003c!--Basic Template V0.0.2 Start --\u003e\n```dataview\nTABLE WITHOUT ID  file.link AS title, tags\nFROM -\"templates\"\nSORT file.mtime, tags desc\nWHERE contains(tags, [[]])\n```\n\u003c!--Basic Template V0.0.2 End --\u003e\n[tags::[[to do]]]\n\n## 시작\n\n### CLI\n\n#### 설치\n\n```bash\ncurl https://sh.edgedb.com --proto '=https' -sSf1 | sh\n```\n\n```bash\ninfo: downloading installer\n\nWelcome to EdgeDB!\n\nThis will install the official EdgeDB command-line tools.\n\nThe edgedb binary will be placed in the user bin directory located at:\n/home/laptop/.local/bin\n\nThis path will then be added to your PATH environment variable by modifying the \nprofile file located at:\n/home/laptop/.profile\n\n┌──────────────────────┬─────────────────────────┐\n│ Installation Path    │ /home/laptop/.local/bin │\n│ Modify PATH Variable │ yes                     │\n│ Profile Files        │ /home/laptop/.profile   │\n└──────────────────────┴─────────────────────────┘\n1) Proceed with installation (default)\n2) Customize installation\n3) Cancel installation\n1\nThe EdgeDB command-line tool is now installed!\n\nWe've updated your shell profile to have /home/laptop/.local/bin in your PATH\nenvironment variable. Next time you open the terminal it will be\nconfigured automatically.\n\nFor this session please run:\nsource \"/home/laptop/.config/edgedb/env\"\nTo initialize a new project, run:\nedgedb project init\n```\n\n#### 프로젝트 초기화\n\n```bash\nedgedb project init\n```\n\n`edgedb.toml` config 파일이 생성되고 `default.esdl` 스키마 파일이 생성됨.\n\n프로젝트를 생성한 디렉토리와 EdgeDB 인스턴스가 연결됨. 해당 디렉토리에서 `edgedb` 호출 시 해당 인스턴스 사용.\n\n인스턴스 관리하는 방법은 [주소](https://www.edgedb.com/docs/intro/instances#ref-intro-instances) 참조\n\n실행중인 인스턴스는 `edgedb instance list`로 확인할 수 있음\n\n#### 스키마 설정\n\n`default.esdl`을 아래와 같이 편집.\n\n```\nmodule default {\n  type Person {\n    required property name -\u003e str;\n  }\n\n  type Movie {\n    property title -\u003e str;\n    multi link actors -\u003e Person;\n  }\n};\n```\n\n- id 속성을 포함하지 않음. EdgeDB는 `id`를 자동으로 만들고, DB에 추가되는 매 오브젝트에 유니크한 UUID를 할당함.\n- `Movie` 타입은 두 개의 **links**를 포함하고 있음: `actors`, `director` (???) EdgeDB에서 링크는 오브젝트 타입간의 관계를 표시하기 위해 사용됨. 외래 키를 사용할 필요가 없음. 이를 통해 JOIN들 없이 딥한 쿼리를 쉽게 짤 수 있게 되는지 알게 될 것임.\n- `default` 라고 불리는 `module` 안에 오브젝트 타입들이 있음. 스키마를 논리적 단위(모듈)로 쪼갤 수 있음. 물론 `default` 단일 모듈에 전체 스키마를 정의하는 것이 일반적임.\n\n#### migration\n\n`edgedb migration create` 로 migration file을 생성할 수 있음. `*.esdl` 파일을 수집해 데이터베이스로 전송함. DB가 이 파일들을 파싱해서, 현재의 스키마와 비교하여, migration 계획을 생성함. 데이터베이스는 이 계획을 CLI로 전송하고, CLI가 migration file을 생성하게됨.\n\nmigration file은 생성되었지만 DB에 적용하지 않은 상태임.\n\n`edgedb migrate` 로 적용.\n\n```bash\n$ edgedb list types\n┌─────────────────┬──────────────────────────────┐\n│ Name            │ Extending                    │\n├─────────────────┼──────────────────────────────┤\n│ default::Movie  │ std::BaseObject, std::Object │\n│ default::Person │ std::BaseObject, std::Object │\n```\n\n잘 적용된 것을 확인할 수 있음.\n\n```\n  type Movie {\n    property title -\u003e str; //이 부분을\n    required property title -\u003e str; //이렇게 수정\n    multi link actors -\u003e Person;\n  }\n```\n\n```\n$ edgedb migration create\ndid you make property 'title' of object type 'default::Movie' required? [y,n,l,c,b,s,q,?]\n\u003e y\nPlease specify an expression to populate existing objects in order to make property 'title' of object type 'default::Movie' required:\nfill_expr\u003e \"untitled\"\nCreated dbschema/migrations/00002.edgeql, id: m1mdw3zntw5yfya4yfbjrvtyyzbzmao7yqdmkcrffvr4aran2oysaa\n```\n\nmigration file을 다시 만드니,\n1. 내가 바꾼 것이 맞는지 확인한 후,\n2. required 로 바꾸면서, 값이 지정되지 않은 오브젝트들의 값은 무엇으로 지정할 것인지 물어봄.\n\n이후 `edgedb migrate` 로 적용.\n\n#### 쿼리 작성\n\n```bash\nedgedb ui\n```\n\n위 명령어로 어드민 대시보드를 열 수 있다.\n\n현재의 '인스턴스' 의 UI를 연 것이고, 이 '인스턴스' 안에서 '데이터베이스'를 만들어볼 수 있음. 일단은 테스트를 위해 기존에 있는 `edgedb`를 사용해보자.\n\n![[Pasted image 20220929122730.png]]\n\nOpen REPL 클릭하여 쿼리를 작성해보자.\n\n```\ninsert Movie {\n  title := \"Dune\"\n};\n```\n\n```\nupdate Movie\nfilter .title = \"Dune\"\nset {\n  actors := {\n    (insert Person { name := \"Timothee Chalamet\" }),\n    (insert Person { name := \"Zendaya\" })\n  }\n};\n```\n\n\n```\nselect Movie {\n  title,\n  actors: {\n    name\n  }\n};\n```\n\n위 쿼리를 거치면 아래의 결과가 나온다.\n\n```\n[\n  {\n    \"title\": \"Dune\",\n    \"actors\": [\n      { \"name\": \"Timothee Chalamet\" },\n      { \"name\": \"Zendaya\" }\n    ]\n  }\n]\n```\n\nUI는 개발 도구이므로 결국에는 각자의 서버에서 edgeDB를 사용해야하는데, 다양한 공식 [클라이언트 라이브러리](https://www.edgedb.com/docs/intro/clients#ref-intro-clients)가 있으므로 찾아보도록 한다.\n\n### 배포\n\nhttps://www.edgedb.com/docs/guides/deployment/index#ref-guide-deployment\n\n\n## 비교\n\n### vs SQL\n\n- SQL은..\n\t- 스키마가 CREATE, ALTER, DELETE, / TABLE, COLUMN 커맨드의 연속으로 이루어져 있다. 한 눈에 스키마를 파악하기 어려움.\n\t- SQL은 데이터를 상대적으로 보관한다. 테이블들간의 연결은 외래 키로 표시되어 JOIN 연산을 사용해야 함.\n- EdgeDB는..\n\t- 테이블들간의 연결을 link 로 나타낸다.\n\t- JOIN을 쓸 필요가 없다.\n```\nselect Movie {\n  title,\n  director: {\n    name\n  }\n}\n```\n\n### vs ORM\n\n- ORM은..\n\t- 모던 OOP 언어 컨셉에 자연스러운 방식으로 스키마를 모델링하고 쿼리를 작성할 수 있게 함\n\t- 하지만,\n\t\t- 스키마가 ORM 라이브러리에 강하게 종속됨.\n\t\t- 특정 프로그래밍 언어 사용이 강제됨.\n\t\t- 제한된 쿼리 기능.\n\t\t- 성능 문제가 있음.\n\t\t- Migration 이 어려울 수 있음.\n- EdgeDB는..\n\t- ORM의 좋은 점만 가져옴\n\t\t- 선언적 모델링\n\t\t- 오브젝트 기반 API\n\t\t- 직관적인 쿼리\n\n\n### 예제\n\nhttps://github.com/edgedb/edgedb-examples\n\n","lastmodified":"2022-10-06T14:49:07.154768861Z","tags":null},"/note/Github-fork-%EC%99%80-template-%EC%9D%98-%EC%B0%A8%EC%9D%B4":{"title":"","content":"# Github fork 와 template 의 차이\n\u003c!--Basic Template V0.0.2 Start --\u003e\n```dataview\nTABLE WITHOUT ID  file.link AS title, tags\nFROM -\"templates\"\nSORT file.mtime, tags desc\nWHERE contains(tags, [[]])\n```\n\u003c!--Basic Template V0.0.2 End --\u003e\n[tags::[[to do]]]\n\nhttps://stackoverflow.com/questions/62082123/github-what-is-the-difference-between-template-and-fork-concepts-and-when-to-us\n\nfork는 원본 리포에 종속적이고, template은 아예 새로 만드는 기능인듯, (boilerplate 느낌)","lastmodified":"2022-10-06T14:49:07.154768861Z","tags":null},"/note/Obsidian-%EC%9D%84-Github-Pages%EB%A1%9C-%ED%98%B8%EC%8A%A4%ED%8C%85%ED%95%98%EA%B8%B0":{"title":"","content":"# Obsidian 을 Github Pages로 호스팅하기\n\u003c!--Basic Template V0.0.2 Start --\u003e\n```dataview\nTABLE WITHOUT ID  file.link AS title, tags\nFROM -\"templates\"\nSORT file.mtime, tags desc\nWHERE contains(tags, [[]])\n```\n\u003c!--Basic Template V0.0.2 End --\u003e\n[tags::[[obsidian 옵시디언]], [[github 깃헙]]]\n\n선요약\n\n1. Obsidian 자체적인 Publish가 제일 안정적으로 퍼블리싱 되지만 가격이 비싸다\n2. 서드 파티 Publish 들은 아직 불안정한 부분이 많음 (2022년 10월 6일 기준)\n\t1. 그나마 현시점에서 가장 채택할만한 서드 파티 Publish는 Quartz이지만, 주요 기능들이 4.0 업데이트 탑재 예정이라 v3.3 은 아직 불안정함\n3. 그렇다고 해서 새로운 Obsidian Publish SSG를 만드는 것도 굉장히 장벽이 높음\n\t1. Obsidian이 일반 Markdown이 아니라 자체적인 확장 신택스를 쓰기 때문에 이걸 옮기는 것이 정말 골때린다\n\n","lastmodified":"2022-10-06T14:49:07.154768861Z","tags":null},"/note/Recentrly-Modified":{"title":"","content":"# Recentrly Modified\n```dataview\nTABLE WITHOUT ID file.link as \"Recently Modified\", choice(none(tag),\"_\",join(tag)) as tag\nSORT file.mtime desc\nLIMIT 10\n```\n[tag::[[메인 Main]]]","lastmodified":"2022-10-06T14:49:07.154768861Z","tags":null},"/note/SolidJS":{"title":"","content":"# SolidJS\n\u003c!--Basic Template V0.0.2 Start --\u003e\n```dataview\nTABLE WITHOUT ID  file.link AS title, tags\nFROM -\"templates\"\nSORT file.mtime, tags desc\nWHERE contains(tags, [[]])\n```\n\u003c!--Basic Template V0.0.2 End --\u003e\n[tags::[[to do]]]\n\n솔리드는 반응형 웹 앱을 만들기 위한 JS 프레임워크다.\n\n- [[SolidJS - 튜토리얼]]\n- [[SolidJS - Getting Started]]\n- [[SolidJS - Router]]\n\n## 시작\n\n```bash\nnpx degit solidjs/templates/ts my-app\ncd my-app\nnpm install # or yarn or pnpm\nnpm run dev # or yarn or pnpm\n```\n\n템플릿을 이용하여 개발 시작한다.\n\n### 컴포넌트란?\n\n컴포넌트는 유저 인터페이스의 일부를 정의하는 함수.\n\nHelloWorld.tsx\n```tsx\nexport function HelloWorld() {\n  return \u003cdiv\u003eHello World!\u003c/div\u003e;\n}\n```\n\n`\u003cdiv\u003e` 엘리먼트 안에 `Hello World!`를 출력하는 컴포넌트. \n\n1.  컴포넌트의 이름은 title-cased.\n   컴포넌트와 다른 JS 함수와의 구분을 도와줌.\n2. 컴포넌트는 HTML처럼 보이는 것을 반환함. JSX라고 부름.\n\n`App.tsx` 를 수정하여 방금 만든 컴포넌트를 출력해보자.\n\n```tsx\nimport { HelloWorld } from \"./HelloWorld\";\nfunction App() {\n  return (\n    \u003cdiv\u003e\n      \u003ch1\u003eWelcome\u003c/h1\u003e\n      \u003cHelloWorld /\u003e\n    \u003c/div\u003e\n  );\n}\nexport default App;\n```\n\n`HelloWorld` 함수를 import한 후 `\u003cHelloWorld/\u003e` 엘리먼트를 쓸 수 있게 됨.\n\n###  JSX란?\n\nhttps://docs.solidjs.com/tutorials/getting-started-with-solid/building-ui-with-components\n\n## Tailwind CSS with SolidJS\n\n[Install Tailwind CSS with SolidJS - Tailwind CSS](https://tailwindcss.com/docs/guides/solidjs)","lastmodified":"2022-10-06T14:49:07.154768861Z","tags":null},"/note/SolidJS-%ED%8A%9C%ED%86%A0%EB%A6%AC%EC%96%BC":{"title":"","content":"# SolidJS - 튜토리얼\n\u003c!--Basic Template V0.0.2 Start --\u003e\n```dataview\nTABLE WITHOUT ID  file.link AS title, tags\nFROM -\"templates\"\nSORT file.mtime, tags desc\nWHERE contains(tags, [[]])\n```\n\u003c!--Basic Template V0.0.2 End --\u003e\n[tags:: [[to do]]]\n\n## 색인\n\nSolidJS 를 다루기 위해 알아야 될 요소는 아래와 같습니다.\n\n- Introduction\n\t- [[SolidJS - Introduction - Basics]]\n\t- [[SolidJS - Introduction - JSX]]\n\t- [[SolidJS - Introduction - Components]]\n\t- [[SolidJS - Introduction - Signals]]\n\t- [[SolidJS - Introduction - Effects]]\n\t- [[SolidJS - Introduction - Derived Signals]]\n\t- [[SolidJS - Introduction - Memos]]\n- Control Flow\n\t- [[SolidJS - Control Flow - Show]]\n\t- [[SolidJS - Control Flow - For]]\n\t- [[SolidJS - Control Flow - Index]]\n\t- [[SolidJS - Control Flow - Switch]]\n\t- [[SolidJS - Control Flow - Dynamic]]\n\t- [[SolidJS - Control Flow - Portal]]\n\t- [[SolidJS - Control Flow - Error Boundary]]\n- Lifecycles\n\t- [[SolidJS - Lifecycles - onMount]]\n\t- [[SolidJS - Lifecycles - onCleanup]]\n- Bindings\n\t- [[SolidJS - Bindings - Events]]\n\t- [[SolidJS - Bindings - Style]]\n\t- [[SolidJS - Bindings - ClassList]]\n\t- [[SolidJS - Bindings - Refs]]\n\t- [[SolidJS - Bindings - Forwarding Refs]]\n\t- [[SolidJS - Bindings - Spreads]]\n\t- [[SolidJS - Bindings - Directives]]\n- Props\n\t- [[SolidJS - Props - Default Props]]\n\t- [[SolidJS - Props - Splitting Props]]\n\t- [[SolidJS - Props - Children]]\n- Stores\n\t- [[SolidJS - Stores - Nested Reactivity]]\n\t- [[SolidJS - Stores - Create Store]]\n\t- [[SolidJS - Stores - Mutation]]\n\t- [[SolidJS - Stores - Context]]\n\t- [[SolidJS - Stores - Immutable Stores]]\n\t- [[SolidJS - Stores - Without Context]]\n- Reactivity\n\t- [[SolidJS - Reactivity - Batching Updates]]\n\t- [[SolidJS - Reactivity - Untrack]]\n\t- [[SolidJS - Reactivity - On]]\n- Async\n\t- [[SolidJS - Reactivity - Lazy Components]]\n\t- [[SolidJS - Reactivity - Resources]]\n\t- [[SolidJS - Reactivity - Suspense]]\n\t- [[SolidJS - Reactivity - Suspens List]]\n\t- [[SolidJS - Reactivity - Transitions]]\n\n위의 요소들은 [Tutorial](https://www.solidjs.com/tutorial/introduction_basics) 에서 확인할 수 있습니다.\n\n","lastmodified":"2022-10-06T14:49:07.154768861Z","tags":null},"/note/SolidJS-Bindings-ClassList":{"title":"","content":"# SolidJS - Bindings - ClassList\n\u003c!--Basic Template V0.0.2 Start --\u003e\n```dataview\nTABLE WITHOUT ID  file.link AS title, tags\nFROM -\"templates\"\nSORT file.mtime, tags desc\nWHERE contains(tags, [[]])\n```\n\u003c!--Basic Template V0.0.2 End --\u003e\n[tags::[[SolidJS]]]\n\nhttps://www.solidjs.com/tutorial/bindings_classlist\n\nSolid는 class를 사용해 엘리먼트의 className 프로퍼티를 설정할 수 있다. 하지만 조건문을 사용해 class를 설정하는 것이 편한 경우가 많은데, 이럴 때 Solid는 키가 class 이름이고 값이 boolean 표현식인 객체를 받는 빌트인 classList JSX 속성을 제공한다. 표현식이 true인 경우 class가 적용되며, false인 경우 삭제된다.\n\n```tsx\n\u003cbutton\n  class={current() === 'foo' ? 'selected' : ''}\n  onClick={() =\u003e setCurrent('foo')}\n\u003efoo\u003c/button\u003e\n```\n\n위의 코드를 classList로 변경한다면\n\n```tsx\n\u003cbutton\n  classList={{selected: current() === 'foo'}}\n  onClick={() =\u003e setCurrent('foo')}\n\u003efoo\u003c/button\u003e\n```\n\n## 문제\n\nTARGET DECK\n전체::개발::solid\n\n---\n\n\u003c!--ankiQ--\u003e\n\n```tsx\n\u003cbutton\n  class={current() === 'foo' ? 'selected' : ''}\n  onClick={() =\u003e setCurrent('foo')}\n\u003efoo\u003c/button\u003e\n```\n\n위의 Solid 코드에서 class=~ 부분을 ClassList를 이용하여 수정하라.\n\n\u003c!--ankiA--\u003e\n\n```tsx\n\u003cbutton\n  classList={{selected: current() === 'foo'}}\n  onClick={() =\u003e setCurrent('foo')}\n\u003efoo\u003c/button\u003e\n```\n\n\u003c!--ankiE--\u003e\n\u003c!--ID: 1664961429246--\u003e\n","lastmodified":"2022-10-06T14:49:07.154768861Z","tags":null},"/note/SolidJS-Bindings-Directives":{"title":"","content":"# SolidJS - Bindings - Directives\n\u003c!--Basic Template V0.0.2 Start --\u003e\n```dataview\nTABLE WITHOUT ID  file.link AS title, tags\nFROM -\"templates\"\nSORT file.mtime, tags desc\nWHERE contains(tags, [[]])\n```\n\u003c!--Basic Template V0.0.2 End --\u003e\n[tags::[[SolidJS]]]\n\nhttps://www.solidjs.com/tutorial/bindings_directives\n\nSolid는 use: 네임스페이스를 사용해 커스텀 디렉티브를 지원한다. \n\n```tsx\n\u003cComponent use:customFunc={() =\u003e doSomething(...)} /\u003e\n```\n\ncustonFunc 는 아래의 형식을 갖는다.\n\n```tsx\nfunction customFunc(element, accessor) {\n\t//doSomething을 실행하기 위해서는\n\taccessor()?.();\n}\n```\n\nelement는 customFunc 를 use: 커스텀 디렉티브로 지정했던 DOM 엘리먼트이며, accessor는 속성에 할당된 값에 대한 getter 함수다.\n\n```tsx\n\u003cdiv class=\"modal\" use:clickOutside={() =\u003e setShow(false)}\u003e\n\tSome Modal\n\u003c/div\u003e\n\nfunction clickOutside(element, accessor) {\n  const onClick = (e) =\u003e !element.contains(e.target) \u0026\u0026 accessor()?.();\n  document.body.addEventListener(\"click\", onClick);\n\n  onCleanup(() =\u003e document.body.removeEventListener(\"click\", onClick));\n}\n```\n\n예를 들어 위와 같이  모달 바깥쪽을 클릭하면 사라지게끔 구현할 수 있다.","lastmodified":"2022-10-06T14:49:07.154768861Z","tags":null},"/note/SolidJS-Bindings-Events":{"title":"","content":"# SolidJS - Bindings - Events\n\u003c!--Basic Template V0.0.2 Start --\u003e\n```dataview\nTABLE WITHOUT ID  file.link AS title, tags\nFROM -\"templates\"\nSORT file.mtime, tags desc\nWHERE contains(tags, [[]])\n```\n\u003c!--Basic Template V0.0.2 End --\u003e\n[tags::[[SolidJS]]]\n\nhttps://www.solidjs.com/tutorial/bindings_events\n\nSolid의 이벤트는 on 접두사가 붙은 속성이다.\n\n모든 on 바인딩은 대소문자를 구분하지 않기 때문에 이벤트 이름은 소문자여야 한다. 예를 들어, `onMouseMove`는 `mousemove`를 모니터링한다.\n\n```tsx\n\u003cdiv onMouseMove={handleMouseMove}\u003e\n  The mouse position is {pos().x} x {pos().y}\n\u003c/div\u003e\n```\n\n`on:` 네임스페이스를 사용하면 대소문자를 구분하고 이벤트 위임을 사용하지 않는다.\n\n```tsx\n\u003cbutton on:DOMContentLoaded={() =\u003e /* Do something */} \u003eClick Me\u003c/button\u003e\n```\n\n## 문제\n\nTARGET DECK\n전체::개발::solid\n\n---\n\n\u003c!--ankiQ--\u003e\n\nSolid 에서 엘리먼트에 이벤트 핸들러를 등록하기 위해서는 크게 2가지 방법이 있다. 어떤 방식이 있고, 어떤 차이가 있는가?\n\n\u003c!--ankiA--\u003e\n\n```tsx\n\u003cdiv onMouseMove={handleMouseMove}\u003e\n  The mouse position is {pos().x} x {pos().y}\n\u003c/div\u003e\n```\n\n```tsx\n\u003cbutton on:DOMContentLoaded={() =\u003e /* Do something */} \u003eClick Me\u003c/button\u003e\n```\n\n1. on 접두사\n\t- ex: onMouseMove\n\t- 대소문자를 구분하지 않는다(이벤트 이름은 소문자여야 함)\n\t- 이벤트 위임 O\n2. on: 네임스페이스\n\t- ex: on:mousemove\n\t- 대소문자를 구분한다\n\t- 이벤트 위임 X\n\n\u003c!--ankiE--\u003e\n\u003c!--ID: 1664959847793--\u003e\n","lastmodified":"2022-10-06T14:49:07.154768861Z","tags":null},"/note/SolidJS-Bindings-Forwarding-Refs":{"title":"","content":"# SolidJS - Bindings - Forwarding Refs\n\u003c!--Basic Template V0.0.2 Start --\u003e\n```dataview\nTABLE WITHOUT ID  file.link AS title, tags\nFROM -\"templates\"\nSORT file.mtime, tags desc\nWHERE contains(tags, [[]])\n```\n\u003c!--Basic Template V0.0.2 End --\u003e\n[tags::[[SolidJS]]]\n\nhttps://www.solidjs.com/tutorial/bindings_forward_refs\n\nRef 전달\n\n컴포넌트 내부의 ref를 부모에게 노출하고 싶은 경우가 많이 있는데, props.ref 를 활용하여 ref를 부모에게 전달할 수 있다.\n\n```tsx\n//부모 컴포넌트\n...\n\treturn \u003cCanvas ref={canvas} /\u003e;\n\n//자식 컴포넌트 (Canvas)\nexport default function Canvas(props) {\n  return \u003ccanvas ref={props.ref} width=\"256\" height=\"256\" /\u003e;\n}\n```\n\n## 문제\n\nTARGET DECK\n전체::개발::solid\n\n---\n\n\u003c!--ankiQ--\u003e\n\n```tsx\n//부모 컴포넌트\n...\n  return \u003cCanvas /\u003e;\n\n//자식 컴포넌트\nexport default function Canvas(props) {\n  return \u003ccanvas width=\"256\" height=\"256\" /\u003e;\n}\n\n```\n\n위의 Solid 코드에서 자식 컴포넌트 Canvas의 ref를 부모 컴포넌트에 전달하고 싶다. 이 경우 어떻게 해야 ref를 부모 컴포넌트에 전달할 수 있겠는가?\n\n\u003c!--ankiA--\u003e\n\n```tsx\n//부모 컴포넌트\n...\n\treturn \u003cCanvas ref={canvas} /\u003e;\n\n//자식 컴포넌트 (Canvas)\nexport default function Canvas(props) {\n  return \u003ccanvas ref={props.ref} width=\"256\" height=\"256\" /\u003e;\n}\n```\n\n\u003c!--ankiE--\u003e\n\u003c!--ID: 1664963394344--\u003e\n","lastmodified":"2022-10-06T14:49:07.154768861Z","tags":null},"/note/SolidJS-Bindings-Refs":{"title":"","content":"# SolidJS - Bindings - Refs\n\u003c!--Basic Template V0.0.2 Start --\u003e\n```dataview\nTABLE WITHOUT ID  file.link AS title, tags\nFROM -\"templates\"\nSORT file.mtime, tags desc\nWHERE contains(tags, [[]])\n```\n\u003c!--Basic Template V0.0.2 End --\u003e\n[tags::[[SolidJS]]]\n\nhttps://www.solidjs.com/tutorial/bindings_refs\n\n2022년 10월 5일 기준, 위 주소의 애니메이션 테스트를 하기 위해서는 [css 파일의 로고 주소를 편집해야 합니다.](https://github.com/solidjs/solid-docs/issues/188) \n\nJSX는 실제 DOM 엘리먼트를 생성하기 때문에, Solid에서는 항상 할당을 통해 DOM에 대한 레퍼런스를 얻을 수 있다. \n\n```tsx\nconst myDiv = \u003cdiv\u003eMy Element\u003c/div\u003e;\n```\n\n예를 들면 위와 같다.\n\n하지만 엘리먼트를 분리하지 않고 하나의 연속된 JSX 템플릿에 넣는 경우 Solid가 생성시 최적화를 더 잘할 수 있다는 이점이 있다.\n\nSolid에서는 ref 속성을 사용해 엘리먼트에 대헌 레퍼런스를 얻을 수 있다.\n\n```tsx\nlet myDiv;\n...\n\u003cdiv ref={myDiv}\u003eMy Element\u003c/div\u003e\n```\n\n위와 같이 변수를 선언하고, ref 속성에 전달하기만 하면 변수가 할당된다. \n\n문서의 DOM에 첨부되기 전에 생성될 때 할당이 발생한다. 생성 전에는 할당되지 않으므로 필요한 경우 onMount 등과 같이 쓰는 것이 좋다.\n\n```tsx\n\u003cdiv ref={el =\u003e /* do something with el... */}\u003eMy Element\u003c/div\u003e\n```\n\n레퍼런스는 콜백 함수의 형태로도 사용 가능한데, 엘리먼트가 첨부될 때까지 기다릴 필요 없이 로직을 캡슐화할 때 편리하다.\n\n## 문제\n\nTARGET DECK\n전체::개발::solid\n\n---\n\n\u003c!--ankiQ--\u003e\n\n```tsx\nfunction App() {\n  let canvas;\n\n\tconst ctx = canvas.getContext(\"2d\");\n\tlet frame = requestAnimationFrame(loop);\n\n\tfunction loop(t) {\n\t\tframe = requestAnimationFrame(loop);\n\n\t\tconst imageData = ctx.getImageData(0, 0, canvas.width, canvas.height);\n\n\t\tfor (let p = 0; p \u003c imageData.data.length; p += 4) {\n\t\t\tconst i = p / 4;\n\t\t\tconst x = i % canvas.width;\n\t\t\tconst y = (i / canvas.height) \u003e\u003e\u003e 0;\n\n\t\t\tconst r = 64 + (128 * x) / canvas.width + 64 * Math.sin(t / 1000);\n\t\t\tconst g = 64 + (128 * y) / canvas.height + 64 * Math.cos(t / 1000);\n\t\t\tconst b = 128;\n\n\t\t\timageData.data[p + 0] = r;\n\t\t\timageData.data[p + 1] = g;\n\t\t\timageData.data[p + 2] = b;\n\t\t\timageData.data[p + 3] = 255;\n\t\t}\n\n\t\tctx.putImageData(imageData, 0, 0);\n\t}\n\n\tonCleanup(() =\u003e cancelAnimationFrame(frame));\n\n\n  return \u003ccanvas width=\"256\" height=\"256\" /\u003e;\n}\n```\n\n위 Solid 코드는 리턴할 캔버스를 편집하여 애니메이션을 적용하는 것이 목적이다.\n\n하지만 canvas 참조를 가져오지 못하고 있는 상황이다.\n\n가장 간단한 것은 `canvas = document.querySelector(\"canvas#ok\");` 와 같이 DOM API로 canvas를 가져오는 것이겠으나, 모종의 이유로 (엘리먼트를 중복 배치하여 쿼리 셀렉터로 고르기 애매한 상황이라거나) 이를 사용할 수 없다면, 반환할 canvas를 지정하기 위해서는 어떻게 해야겠는가?\n\n\u003c!--ankiA--\u003e\n\n1. const ctx=~ 절부터 onMount로 감싼다.\n2. ref 지정\n\t- `return \u003ccanvas ref={canvas} width=\"256\" height=\"256\" /\u003e;`\n\n```tsx\nfunction App() {\n  let canvas;\n  onMount(() =\u003e { // \u003c-- 1\n    const ctx = canvas.getContext(\"2d\");\n    let frame = requestAnimationFrame(loop);\n\n    function loop(t) {\n      frame = requestAnimationFrame(loop);\n\n      const imageData = ctx.getImageData(0, 0, canvas.width, canvas.height);\n\n      for (let p = 0; p \u003c imageData.data.length; p += 4) {\n        const i = p / 4;\n        const x = i % canvas.width;\n        const y = (i / canvas.height) \u003e\u003e\u003e 0;\n\n        const r = 64 + (128 * x) / canvas.width + 64 * Math.sin(t / 1000);\n        const g = 64 + (128 * y) / canvas.height + 64 * Math.cos(t / 1000);\n        const b = 128;\n\n        imageData.data[p + 0] = r;\n        imageData.data[p + 1] = g;\n        imageData.data[p + 2] = b;\n        imageData.data[p + 3] = 255;\n      }\n\n      ctx.putImageData(imageData, 0, 0);\n    }\n\n    onCleanup(() =\u003e cancelAnimationFrame(frame));\n  });\n\n  return \u003ccanvas ref={canvas} width=\"256\" height=\"256\" /\u003e; //\u003c-- 2\n}\n\n```\n\n\u003c!--ankiE--\u003e\n\u003c!--ID: 1664962643991--\u003e\n","lastmodified":"2022-10-06T14:49:07.154768861Z","tags":null},"/note/SolidJS-Bindings-Spreads":{"title":"","content":"# SolidJS - Bindings - Spreads\n\u003c!--Basic Template V0.0.2 Start --\u003e\n```dataview\nTABLE WITHOUT ID  file.link AS title, tags\nFROM -\"templates\"\nSORT file.mtime, tags desc\nWHERE contains(tags, [[]])\n```\n\u003c!--Basic Template V0.0.2 End --\u003e\n[tags::[[SolidJS]]]\n\nhttps://www.solidjs.com/tutorial/bindings_spreads\n\n때로는 컴포넌트와 엘리먼트에서 다수의 속성을 받아서 아래쪽으로 전달할 때, 하나씩 전달하기보다 객체로 전달하는 것이 합리적이다. 디자인 시스템을 만들 때 일반적인 관행인 컴포넌트 안에서 DOM 엘리먼트를 래핑할 때 특히 그렇다.\n\n```tsx\nconst pkg = {\n  name: \"solid-js\",\n  version: 1,\n  speed: \"⚡️\",\n  website: \"https://solidjs.com\",\n};\n\nfunction App() {\n  return (\n    \u003cInfo\n      name={pkg.name}\n      version={pkg.version}\n      speed={pkg.speed}\n      website={pkg.website}\n    /\u003e\n  );\n}\n```\n\n이런 경우 스프레드 연산자(`...`)를 사용한다.\n\n```tsx\nconst pkg = {\n  name: \"solid-js\",\n  version: 1,\n  speed: \"⚡️\",\n  website: \"https://solidjs.com\",\n};\n\nfunction App() {\n  return \u003cInfo {...pkg} /\u003e;\n}\n```\n\n## 문제\n\nTARGET DECK\n전체::개발::solid\n\n---\n\n\u003c!--ankiQ--\u003e\n\n```tsx\nconst pkg = {\n  name: \"solid-js\",\n  version: 1,\n  speed: \"⚡️\",\n  website: \"https://solidjs.com\",\n};\n\nfunction App() {\n  return (\n    \u003cInfo\n      name={pkg.name}\n      version={pkg.version}\n      speed={pkg.speed}\n      website={pkg.website}\n    /\u003e\n  );\n}\n```\n\n위 Solid 코드에서 Info 컴포넌트에 속성을 전달하는 것을 더 단순화할 수 있다. 어떻게 하면 되는가?\n\n\u003c!--ankiA--\u003e\n\n```tsx\nconst pkg = {\n  name: \"solid-js\",\n  version: 1,\n  speed: \"⚡️\",\n  website: \"https://solidjs.com\",\n};\n\nfunction App() {\n  return \u003cInfo {...pkg} /\u003e;\n}\n```\n\n스프레드 연산자를 사용한다.\n\n\u003c!--ankiE--\u003e\n\u003c!--ID: 1664963605046--\u003e\n\n","lastmodified":"2022-10-06T14:49:07.154768861Z","tags":null},"/note/SolidJS-Bindings-Style":{"title":"","content":"# SolidJS - Bindings - Style\n\u003c!--Basic Template V0.0.2 Start --\u003e\n```dataview\nTABLE WITHOUT ID  file.link AS title, tags\nFROM -\"templates\"\nSORT file.mtime, tags desc\nWHERE contains(tags, [[]])\n```\n\u003c!--Basic Template V0.0.2 End --\u003e\n[tags::[[SolidJS]]]\n\nhttps://www.solidjs.com/tutorial/bindings_style\n\nSolid의 style 속성은 스타일 문자열이나 객체를 받는다.\n\n```tsx\n\u003cdiv style={`color: green; background-color: ${state.color}; height: ${state.height}px`} /\u003e\n```\n\n문자열로 위와 같이 지정할 수 있다.\n\n```tsx\n\u003cdiv style={{\n  color: \"green\",\n  \"background-color\": state.color,\n  height: state.height + \"px\" }}\n/\u003e\n```\n\n위와 같이 객체로도 지정할 수 있다. 단 객체로 지정할 때 -로 구분된 속성 이름은 따옴표로 묶어야 한다.\n\n```tsx\n\u003cdiv style={{ \"--my-custom-color\": state.themeColor }} /\u003e\n```\n\nCSS 변수도 설정할 수 있다.\n\nbackgroundColor 와 같은 자바스크립트 카멜 케이스 버전이 아닌 `background-color` 와 같은 소문자이면서 -로 구분된 속성 이름을 사용한다.\n\n## 문제\n\nTARGET DECK\n전체::개발::solid\n\n---\n\n\u003c!--ankiQ--\u003e\n\n```tsx\n\u003cdiv\u003eSome Text\u003c/div\u003e;\n```\n\n위의 Solid div 엘리먼트를 color: red, font-size: 18px 로 스타일링하시오.\n\n\u003c!--ankiA--\u003e\n\n```tsx\n\u003cdiv style={{color:\"red\", \"font-size\":18+\"px\"}}\u003eSome Text\u003c/div\u003e;\n```\n\n\u003c!--ankiE--\u003e\n\u003c!--ID: 1664961205088--\u003e\n","lastmodified":"2022-10-06T14:49:07.154768861Z","tags":null},"/note/SolidJS-Control-Flow-Dynamic":{"title":"","content":"# SolidJS - Control Flow - Dynamic\n\u003c!--Basic Template V0.0.2 Start --\u003e\n```dataview\nTABLE WITHOUT ID  file.link AS title, tags\nFROM -\"templates\"\nSORT file.mtime, tags desc\nWHERE contains(tags, [[]])\n```\n\u003c!--Basic Template V0.0.2 End --\u003e\n[tags::[[SolidJS]]]\n\nhttps://www.solidjs.com/tutorial/flow_dynamic\n\n많은 엘리먼트 들 중에서, 값에 따라 하나의 엘리먼트를 선택해서 보여줘야 하는 경우, Show 컴포넌트나 Switch/Match 컴포넌트를 이용하는 것은 코드를 굉장히 길어지게 한다.\n\n네이티브 엘리먼트 문자열이나 컴포넌트 함수를 전달하는 환경이라면 Dynamic 컴포넌트를 이용하여 이를 단순화할 수 있다.\n\n```tsx\nconst RedThing = () =\u003e \u003cstrong style=\"color: red\"\u003eRed Thing\u003c/strong\u003e;\nconst GreenThing = () =\u003e \u003cstrong style=\"color: green\"\u003eGreen Thing\u003c/strong\u003e;\nconst BlueThing = () =\u003e \u003cstrong style=\"color: blue\"\u003eBlue Thing\u003c/strong\u003e;\n\nconst options = {\n  red: RedThing,\n  green: GreenThing,\n  blue: BlueThing\n}\n```\n\n위와 같이 조건에 따라 출력해야 하는 컴포넌트 목록이 있고,\n\n```tsx\n  \u003cselect onInput={e =\u003e setSelected(e.currentTarget.value)}\u003e\n\t\u003cFor each={Object.keys(options)}\u003e{\n\t  color =\u003e \u003coption value={color}\u003e{color}\u003c/option\u003e\n\t}\u003c/For\u003e\n  \u003c/select\u003e\n```\n\nselect 를 통해 렌더링할 컴포넌트를 지정하는 환경이라면,\n\n```tsx\n  \u003cSwitch fallback={\u003cBlueThing /\u003e}\u003e\n\t\u003cMatch when={selected() === \"red\"} \u003e\u003cRedThing /\u003e\u003c/Match\u003e\n\t\u003cMatch when={selected() === \"green\"}\u003e\u003cGreenThing /\u003e\u003c/Match\u003e\n  \u003c/Switch\u003e\n```\n\n위처럼 Switch, Match 를 쓰는 것은 간결하지 않다.\n\nDynamic 컴포넌트를 사용한다면\n\n```tsx\n\u003cDynamic component={options[selected()]} /\u003e\n```\n\n와 같이 수정할 수 있다.\n\n## 문제\n\nTARGET DECK\n전체::개발::solid\n\n---\n\n\u003c!--ankiQ--\u003e\n\n```tsx\nconst RedThing = () =\u003e \u003cstrong style=\"color: red\"\u003eRed Thing\u003c/strong\u003e;\nconst GreenThing = () =\u003e \u003cstrong style=\"color: green\"\u003eGreen Thing\u003c/strong\u003e;\nconst BlueThing = () =\u003e \u003cstrong style=\"color: blue\"\u003eBlue Thing\u003c/strong\u003e;\n\nconst options = {\n  red: RedThing,\n  green: GreenThing,\n  blue: BlueThing\n}\n\n...\n\n  \u003cselect onInput={e =\u003e setSelected(e.currentTarget.value)}\u003e\n\t\u003cFor each={Object.keys(options)}\u003e{\n\t  color =\u003e \u003coption value={color}\u003e{color}\u003c/option\u003e\n\t}\u003c/For\u003e\n  \u003c/select\u003e\n\n  \u003cSwitch fallback={\u003cBlueThing /\u003e}\u003e\n\t\u003cMatch when={selected() === \"red\"} \u003e\u003cRedThing /\u003e\u003c/Match\u003e\n\t\u003cMatch when={selected() === \"green\"}\u003e\u003cGreenThing /\u003e\u003c/Match\u003e\n  \u003c/Switch\u003e\n\n```\n\n위의 solid 코드는 select 한 값으로 지정된 컴포넌트를 렌더링하려는 목적으로 작성되었다.\n\n어떤 컴포넌트를 이용하면 Switch/Match 컴포넌트를 간소화할 수 있다. 어떻게 작성해야겠는가?\n\n\u003c!--ankiA--\u003e\n\n```tsx\n\u003cDynamic component={options[selected()]} /\u003e\n```\n\n\u003c!--ankiE--\u003e\n\u003c!--ID: 1664954231227--\u003e\n","lastmodified":"2022-10-06T14:49:07.154768861Z","tags":null},"/note/SolidJS-Control-Flow-Error-Boundary":{"title":"","content":"# SolidJS - Control Flow - Error Boundary\n\u003c!--Basic Template V0.0.2 Start --\u003e\n```dataview\nTABLE WITHOUT ID  file.link AS title, tags\nFROM -\"templates\"\nSORT file.mtime, tags desc\nWHERE contains(tags, [[]])\n```\n\u003c!--Basic Template V0.0.2 End --\u003e\n[tags::[[SolidJS]]]\n\nhttps://www.solidjs.com/tutorial/flow_error_boundary\n\nUI에서 발생하는 자바스크립트 오류로 전체 앱이 중단되면 안 된다. ErrorBoundary 컴포넌트는 자식 컴포넌트 트리에서 발생하는 자바스크립트 에러를 캐치해서, 에러를 기록하고, 충돌이 발생한 컴포넌트 트리 대신 fallback UI를 표시한다.\n\n```tsx\nconst Broken = (props) =\u003e {\n  throw new Error(\"Oh No\");\n  return \u003c\u003eNever Getting Here\u003c/\u003e\n}\n\n...\n\n\u003cErrorBoundary fallback={err =\u003e err}\u003e\n  \u003cBroken /\u003e\n\u003c/ErrorBoundary\u003e\n```\n\n## 문제\n\nTARGET DECK\n전체::개발::solid\n\n---\n\n\u003c!--ankiQ--\u003e\n```tsx\nconst Broken = (props) =\u003e {\n  throw new Error(\"Oh No\");\n  return \u003c\u003eNever Getting Here\u003c/\u003e\n}\n\nfunction App() {\n  return (\n    \u003c\u003e\n      \u003cdiv\u003eBefore\u003c/div\u003e\n      \u003cBroken /\u003e\n      \u003cdiv\u003eAfter\u003c/div\u003e\n    \u003c/\u003e\n  );\n}\n```\n\n위의 Broken 컴포넌트는 무조건 에러가 발생한다. 따라서 App 컴포넌트는 렌더링이 중단될 것이다.\n\nBroken 컴포넌트에서 발생한 에러를 캐치해서 그대로 italic 엘리먼트로 감싸 출력하고 싶다면 어떻게 해야겠는가?\n\n\u003c!--ankiA--\u003e\n\n```tsx\n  \u003cdiv\u003eBefore\u003c/div\u003e\n\t\u003cErrorBoundary fallback={err =\u003e (\u003ci\u003e{err.toString()}\u003c/i\u003e)}\u003e\n\t  \u003cBroken /\u003e\n\t\u003c/ErrorBoundary\u003e\n  \u003cdiv\u003eAfter\u003c/div\u003e\n```\n\n\u003c!--ankiE--\u003e\n\u003c!--ID: 1664956299102--\u003e\n","lastmodified":"2022-10-06T14:49:07.154768861Z","tags":null},"/note/SolidJS-Control-Flow-For":{"title":"","content":"# SolidJS - Control Flow - For\n\u003c!--Basic Template V0.0.2 Start --\u003e\n```dataview\nTABLE WITHOUT ID  file.link AS title, tags\nFROM -\"templates\"\nSORT file.mtime, tags desc\nWHERE contains(tags, [[]])\n```\n\u003c!--Basic Template V0.0.2 End --\u003e\n[tags::[[SolidJS]]]\n\nhttps://www.solidjs.com/tutorial/flow_for\n\nFor 컴포넌트를 사용해 객체 배열에 대해 반복을 편하게 할 수 있다. \n\n```tsx\n    \u003cul\u003e\n      \u003cli\u003e\n        \u003ca target=\"_blank\" href=\"\"\u003e\n          1: Garfield\n        \u003c/a\u003e\n      \u003c/li\u003e\n    \u003c/ul\u003e\n```\n\n위 코드에서 li 컴포넌트를 cats() 로 전개하고 싶다면,\n\n```tsx\n\u003cFor each={cats()}\u003e{(cat, i) =\u003e\n  \u003cli\u003e\n    \u003ca target=\"_blank\" href={`https://www.youtube.com/watch?v=${cat.id}`}\u003e\n      {i() + 1}: {cat.name}\n    \u003c/a\u003e\n  \u003c/li\u003e\n}\u003c/For\u003e\n```\n\n이렇게 수정할 수 있다.\n\n주의해야 하는 점은 다음과 같다.\n1. 인덱스는 상수가 아닌 Signal 이다. (`i()`)\n2. each prop은 배열 타입만 사용해야 한다.\n\t1. iterable 객체를 배열로 바꾸려면\n\t\t1. Object.keys\n\t\t2. Array.from\n\t\t3. 스프레드 구문 (`...`)\n\n---\n\n## 문제\n\nTARGET DECK\n전체::개발::solid\n\n\u003c!--ankiQ--\u003e\n\n```tsx\n    \u003cul\u003e\n      \u003cli\u003e\n        \u003ca target=\"_blank\" href=\"\"\u003e\n          1: Garfield\n        \u003c/a\u003e\n      \u003c/li\u003e\n    \u003c/ul\u003e\n```\n\n위 solid tsx 코드에서 li 컴포넌트를 cats() 로 전개하고 싶다면 어떻게 해야겠는가?\n\ncats()는 배열임이 보장되어있다.\n\n\u003c!--ankiA--\u003e\n\n```tsx\n\u003cFor each={cats()}\u003e{(cat, i) =\u003e\n  \u003cli\u003e\n    \u003ca target=\"_blank\" href={`https://www.youtube.com/watch?v=${cat.id}`}\u003e\n      {i() + 1}: {cat.name}\n    \u003c/a\u003e\n  \u003c/li\u003e\n}\u003c/For\u003e\n```\n\n인덱스 i 가 상수가 아니라 시그널로 쓰여지고 있음에 주의한다.\n\n\u003c!--ankiE--\u003e\n\u003c!--ID: 1664950271994--\u003e\n\n---\n\n\u003c!--ankiQ--\u003e\n\nsolid의 For 컴포넌트의 each prop에는 배열만 올 수 있다. Iterable 객체를 each Prop에 넣고 싶은 경우 어떤 해결 방안이 있겠는가?\n\n\u003c!--ankiA--\u003e\n\n1. Array.from\n2. Object.keys\n3. Spread Operator\n\n\u003c!--ankiE--\u003e\n\u003c!--ID: 1664950272011--\u003e\n\n","lastmodified":"2022-10-06T14:49:07.154768861Z","tags":null},"/note/SolidJS-Control-Flow-Index":{"title":"","content":"# SolidJS - Control Flow - Index\n\u003c!--Basic Template V0.0.2 Start --\u003e\n```dataview\nTABLE WITHOUT ID  file.link AS title, tags\nFROM -\"templates\"\nSORT file.mtime, tags desc\nWHERE contains(tags, [[]])\n```\n\u003c!--Basic Template V0.0.2 End --\u003e\n[tags::[[SolidJS]]]\n\nhttps://www.solidjs.com/tutorial/flow_index\n\nIndex 컴포넌트는 For 컴포넌트와 유사하게 객체 배열에 대한 반복을 위해 사용된다.\n\n단, Index 컴포넌트가 For 컴포넌트와 다른 점은 아래와 같다.\n1. 반환되는 컴포넌트 전체가 다시 렌더링되는 For과 달리 Index는 컴포넌트에서 item을 참조하는 부분만 변경된다.\n2. For 컴포넌트와는 정반대로 index 가 고정된 상수 값이고, item이 시그널이다.\n\nFor 컴포넌트는 배열의 각 데이터 조각에 대해 관심을 가지며, 해당 데이터의 위치가 변경될 수 있다. Index 컴포넌트는 배열의 각 인덱스에 관심을 가지며, 각 인덱스의 내용이 변경될 수 있다.\n\n```tsx\n\u003cFor each={cats()}\u003e{(cat, i) =\u003e\n  \u003cli\u003e\n    \u003ca target=\"_blank\" href={`https://www.youtube.com/watch?v=${cat.id}`}\u003e\n      {i() + 1}: {cat.name}\n    \u003c/a\u003e\n  \u003c/li\u003e\n}\u003c/For\u003e\n```\n\n```tsx\n\u003cIndex each={cats()}\u003e{(cat, i) =\u003e\n  \u003cli\u003e\n    \u003ca target=\"_blank\" href={`https://www.youtube.com/watch?v=${cat().id}`}\u003e\n      {i + 1}: {cat().name}\n    \u003c/a\u003e\n  \u003c/li\u003e\n}\u003c/Index\u003e\n```\n\nFor 컴포넌트와 굉장히 유사한 반면 item 과 index 의 성질이 정반대임을 알 수 있다.\n\n## 참고\n\n[solid js - SolidJS: For vs Index - Stack Overflow](https://stackoverflow.com/questions/70819075/solidjs-for-vs-index)\n\n[solid-docs/faq.md at main · solidjs/solid-docs](https://github.com/solidjs/solid-docs/blob/main/langs/en/guides/faq.md#why-shouldnt-i-use-map-in-my-template-and-whats-the-difference-between-for-and-index)\n\n## 문제\nTARGET DECK\n전체::개발::solid\n\n---\n\n\u003c!--ankiQ--\u003e\n\nSolid의 For 컴포넌트와 Index 컴포넌트는 each prop에 있는 배열을 반복한다는 점에서 유사하나, 아이템 변경 시 렌더링 관련하여 차이가 있다. 어떤 차이인가?\n\n\u003c!--ankiA--\u003e\n\nFor 컴포넌트는 반환되는 엘리먼트 전체가 재 렌더링되고, Index 컴포넌트는 엘리먼트는 유지한 채  Item 에 의해 변경되는 부분만 수정한다.\n\n\u003c!--ankiE--\u003e\n\u003c!--ID: 1664953255292--\u003e\n\n---\n\n\u003c!--ankiQ--\u003e\n\n```tsx\n\u003cFor each={cats()}\u003e{(cat, i) =\u003e\n  \u003cli\u003e\n    \u003ca target=\"_blank\" href={`https://www.youtube.com/watch?v=${cat.id}`}\u003e\n      {i() + 1}: {cat.name}\n    \u003c/a\u003e\n  \u003c/li\u003e\n}\u003c/For\u003e\n```\n\n위 Solid For 컴포넌트 코드를 Index 컴포넌트로 수정한다면 어떻게 해야겠는가?\n\n\u003c!--ankiA--\u003e\n\n```tsx\n\u003cIndex each={cats()}\u003e{(cat, i) =\u003e\n  \u003cli\u003e\n    \u003ca target=\"_blank\" href={`https://www.youtube.com/watch?v=${cat().id}`}\u003e\n      {i + 1}: {cat().name}\n    \u003c/a\u003e\n  \u003c/li\u003e\n}\u003c/Index\u003e\n```\n\ncats -\u003e cats()\n\ni() -\u003e i\n\n\u003c!--ankiE--\u003e\n\u003c!--ID: 1664953255323--\u003e\n","lastmodified":"2022-10-06T14:49:07.154768861Z","tags":null},"/note/SolidJS-Control-Flow-Portal":{"title":"","content":"# SolidJS - Control Flow - Portal\n\u003c!--Basic Template V0.0.2 Start --\u003e\n```dataview\nTABLE WITHOUT ID  file.link AS title, tags\nFROM -\"templates\"\nSORT file.mtime, tags desc\nWHERE contains(tags, [[]])\n```\n\u003c!--Basic Template V0.0.2 End --\u003e\n[tags::[[SolidJS]]]\n\nhttps://www.solidjs.com/tutorial/flow_portal\n\n때로는 앱의 정상적인 플로우 외부에 엘리먼트를 삽입하는 것이 더 좋은 경우가 있다. Z-index 를 이용할 수도 있지만 때때로 모달과 같은 플로팅 엘리먼트에 대한 렌더링 컨텍스트를 처리하기에 부족한 경우가 있다.\n\n선택한 위치에 자식 콘텐츠가 삽입되는 [Portal 컴포넌트](https://www.solidjs.com/docs/latest/api#portal)가 있다. 기본적으로 해당 엘리먼트는 document.body의 div 에 렌더링 된다.\n\n사용할 수 있는 Prop은 다음과 같다.\n- mount?\n\t- 자식 엘리먼트를 마운트할 노드를 지정한다.\n\t- `mount={document.getElementByID(\"modal\")}`\n- useShadow?\n\t- 스타일 격리를 위해 섀도루 루트에 엘리먼트를 배치한다.\n- isSVG?\n\t- SVG 엘리먼트에 삽입하는 경우 기본적으로 div 로 감싸 삽입하는 것이 문제가 될 수 있음\n\t- isSVG 를 이용하여 div 삽입을 방지할 수 있다\n- children\n\t- Portal 태그로 감싼 자식 엘리먼트\n\n```tsx\n\u003cPortal\u003e\n  \u003cdiv class=\"popup\"\u003e\n    \u003ch1\u003ePopup\u003c/h1\u003e\n    \u003cp\u003eSome text you might need for something or other.\u003c/p\u003e\n  \u003c/div\u003e\n\u003c/Portal\u003e\n```\n\n## 문제\n\nTARGET DECK\n전체::개발\n\n---\n\n\u003c!--ankiQ--\u003e\n\n```tsx\n\u003cdiv class=\"app-container\"\u003e\n  \u003cp\u003eJust some text inside a div that has a restricted size.\u003c/p\u003e\n  \u003cdiv class=\"popup\"\u003e\n\t\u003ch1\u003ePopup\u003c/h1\u003e\n\t\u003cp\u003eSome text you might need for something or other.\u003c/p\u003e\n  \u003c/div\u003e\n\u003c/div\u003e\n);\n```\n\n위 solid 코드에서 div#popup 은 일반적인 flow에서 벗어나 body에 배치하고 싶다면 어떻게 수정해야 겠는가?\n\n\u003c!--ankiA--\u003e\n\n```tsx\n\u003cdiv class=\"app-container\"\u003e\n  \u003cp\u003eJust some text inside a div that has a restricted size.\u003c/p\u003e\n  \u003cPortal\u003e\n\t\u003cdiv class=\"popup\"\u003e\n\t  \u003ch1\u003ePopup\u003c/h1\u003e\n\t  \u003cp\u003eSome text you might need for something or other.\u003c/p\u003e\n\t\u003c/div\u003e\n  \u003c/Portal\u003e\n\u003c/div\u003e\n```\n\ndocument.body.div 에 배치된다.\n\n\u003c!--ankiE--\u003e\n\u003c!--ID: 1664955746016--\u003e\n","lastmodified":"2022-10-06T14:49:07.154768861Z","tags":null},"/note/SolidJS-Control-Flow-Show":{"title":"","content":"# SolidJS - Control Flow - Show\n\u003c!--Basic Template V0.0.2 Start --\u003e\n```dataview\nTABLE WITHOUT ID  file.link AS title, tags\nFROM -\"templates\"\nSORT file.mtime, tags desc\nWHERE contains(tags, [[]])\n```\n\u003c!--Basic Template V0.0.2 End --\u003e\n[tags::[[SolidJS]]]\n\nhttps://www.solidjs.com/tutorial/flow_show\n\n가장 기본적인 제어 흐름은 조건문이다. Solid 에서는 다음의 세 가지 방법으로 조건문을 사용할 수 있다.\n1. 삼항 연산자(`a ? b : c`)\n2. 불 표현식 (`a \u0026\u0026 b`)\n3. Show 컴포넌트\n\n## 원본\n\n```tsx\n  return (\n    \u003c\u003e\n      \u003cbutton onClick={toggle}\u003eLog out\u003c/button\u003e\n      \u003cbutton onClick={toggle}\u003eLog in\u003c/button\u003e\n    \u003c/\u003e\n  );\n```\n\n`loggedIn` 시그널에 따라 Log out과 Log in을 바꿔서 표시하려고 한다. 가장 간단한 것은 내부의 Log out, Log in 텍스트를 `loggedIn`에 따라 바꿔주는 것이겠지만 조건 상 log out 버튼과 log in 버튼이 수행해야 하는 역할이 달라 엘리먼트 단위로 구분해야 한다고 가정하자.\n\n## 삼항 연산자\n\n```tsx\n  return (\n    \u003c\u003e\n    {\n      loggedIn()\n      ? \u003cbutton onClick={toggle}\u003eLog out\u003c/button\u003e\n      : \u003cbutton onClick={toggle}\u003eLog in\u003c/button\u003e\n    }\n    \u003c/\u003e\n  );\n```\n\n## 불 표현식\n\n```tsx\n  return (\n    \u003c\u003e\n    {\n      loggedIn() \u0026\u0026 \u003cbutton onClick={toggle}\u003eLog out\u003c/button\u003e\n    }\n    {\n      !loggedIn() \u0026\u0026 \u003cbutton onClick={toggle}\u003eLog in\u003c/button\u003e\n    }\n    \u003c/\u003e\n  );\n```\n\n## Show 컴포넌트\n\n`solid-js`에서 `Show`를 import 해야 한다.\n\n```tsx\n  return (\n    \u003cShow\n      when={loggedIn()}\n      fallback={\u003cbutton onClick={toggle}\u003eLog in\u003c/button\u003e}\n    \u003e\n      \u003cbutton onClick={toggle}\u003eLog out\u003c/button\u003e\n    \u003c/Show\u003e\n  );\n```\n\nfallback prop은 else처럼 동작하며, when에 넘겨진 조건이 false인 경우에만 표시된다.\n\n---\n## 문제\n\nTARGET DECK\n전체::개발::solid\n\n\u003c!--ankiQ--\u003e\n```tsx\n  return (\n    \u003c\u003e\n      \u003cbutton onClick={toggle}\u003eLog out\u003c/button\u003e\n      \u003cbutton onClick={toggle}\u003eLog in\u003c/button\u003e\n    \u003c/\u003e\n  );\n```\n\n`loggedIn` 시그널에 따라 Log out과 Log in을 바꿔서 표시하려고 한다. 가장 간단한 것은 내부의 Log out, Log in 텍스트를 `loggedIn`에 따라 바꿔주는 것이겠지만 조건 상 log out 버튼과 log in 버튼이 수행해야 하는 역할이 달라 엘리먼트 단위로 구분해야 한다고 가정하자.\n\n이를 삼항 연산자로 해결한다면 어떻게 수정할 수 있겠는가?\n\n\u003c!--ankiA--\u003e\n\n```tsx\n  return (\n    \u003c\u003e\n    {\n      loggedIn()\n      ? \u003cbutton onClick={toggle}\u003eLog out\u003c/button\u003e\n      : \u003cbutton onClick={toggle}\u003eLog in\u003c/button\u003e\n    }\n    \u003c/\u003e\n  );\n```\n\n\u003c!--ankiE--\u003e\n\u003c!--ID: 1664949405066--\u003e\n\n\n\u003c!--ankiQ--\u003e\n```tsx\n  return (\n    \u003c\u003e\n      \u003cbutton onClick={toggle}\u003eLog out\u003c/button\u003e\n      \u003cbutton onClick={toggle}\u003eLog in\u003c/button\u003e\n    \u003c/\u003e\n  );\n```\n\n`loggedIn` 시그널에 따라 Log out과 Log in을 바꿔서 표시하려고 한다. 가장 간단한 것은 내부의 Log out, Log in 텍스트를 `loggedIn`에 따라 바꿔주는 것이겠지만 조건 상 log out 버튼과 log in 버튼이 수행해야 하는 역할이 달라 엘리먼트 단위로 구분해야 한다고 가정하자.\n\n이를 Show 컴포넌트로 해결한다면 어떻게 수정할 수 있겠는가?\n\n\u003c!--ankiA--\u003e\n\n```tsx\n  return (\n    \u003cShow\n      when={loggedIn()}\n      fallback={\u003cbutton onClick={toggle}\u003eLog in\u003c/button\u003e}\n    \u003e\n      \u003cbutton onClick={toggle}\u003eLog out\u003c/button\u003e\n    \u003c/Show\u003e\n  );\n```\n\n\u003c!--ankiE--\u003e\n\u003c!--ID: 1664949405098--\u003e\n","lastmodified":"2022-10-06T14:49:07.154768861Z","tags":null},"/note/SolidJS-Control-Flow-Switch":{"title":"","content":"# SolidJS - Control Flow - Switch\n\u003c!--Basic Template V0.0.2 Start --\u003e\n```dataview\nTABLE WITHOUT ID  file.link AS title, tags\nFROM -\"templates\"\nSORT file.mtime, tags desc\nWHERE contains(tags, [[]])\n```\n\u003c!--Basic Template V0.0.2 End --\u003e\n[tags::[[SolidJS]]]\n\nhttps://www.solidjs.com/tutorial/flow_switch\n\n때로는 2개 이상의 상호 배타적 결과가 있는 조건문을 처리해야 한다. 이런 경우를 위해 switch/case를 본떠 만든 Switch, Match 컴포넌트가 있다.\n\n각 조건을 비교해서 조건식이 true인 첫 번째 항목을 렌더링한다. 모두 매칭되지 않을 경우 fallback을 렌더링한다.\n\n```tsx\n\u003cShow\n  when={x() \u003e 10}\n  fallback={\n\t\u003cShow\n\t  when={5 \u003e x()}\n\t  fallback={\u003cp\u003e{x()} is between 5 and 10\u003c/p\u003e}\n\u003e\n\t  \u003cp\u003e{x()} is less than 5\u003c/p\u003e\n\t\u003c/Show\u003e\n  }\n\u003e\n  \u003cp\u003e{x()} is greater than 10\u003c/p\u003e\n\u003c/Show\u003e\n```\n\n위 코드의 경우 아래와 같이 바꿀 수 있다.\n\n```tsx\n\u003cSwitch fallback={\u003cp\u003e{x()} is between 5 and 10\u003c/p\u003e}\u003e\n  \u003cMatch when={x() \u003e 10}\u003e\n    \u003cp\u003e{x()} is greater than 10\u003c/p\u003e\n  \u003c/Match\u003e\n  \u003cMatch when={5 \u003e x()}\u003e\n    \u003cp\u003e{x()} is less than 5\u003c/p\u003e\n  \u003c/Match\u003e\n\u003c/Switch\u003e\n```\n\n## 문제\n\nTARGET DECK\n전체::개발::solid\n\n---\n\n\u003c!--ankiQ--\u003e\n\n```tsx\n\u003cShow\n  when={x() \u003e 10}\n  fallback={\n\t\u003cShow\n\t  when={5 \u003e x()}\n\t  fallback={\u003cp\u003e{x()} is between 5 and 10\u003c/p\u003e}\n\u003e\n\t  \u003cp\u003e{x()} is less than 5\u003c/p\u003e\n\t\u003c/Show\u003e\n  }\n\u003e\n  \u003cp\u003e{x()} is greater than 10\u003c/p\u003e\n\u003c/Show\u003e\n```\n\n위 solid Show 코드를 Switch/Match 컴포넌트를 이용하여 수정하시오.\n\n\u003c!--ankiA--\u003e\n\n```tsx\n\u003cSwitch fallback={\u003cp\u003e{x()} is between 5 and 10\u003c/p\u003e}\u003e\n  \u003cMatch when={x() \u003e 10}\u003e\n    \u003cp\u003e{x()} is greater than 10\u003c/p\u003e\n  \u003c/Match\u003e\n  \u003cMatch when={5 \u003e x()}\u003e\n    \u003cp\u003e{x()} is less than 5\u003c/p\u003e\n  \u003c/Match\u003e\n\u003c/Switch\u003e\n```\n\n\u003c!--ankiE--\u003e\n\u003c!--ID: 1664953517827--\u003e\n","lastmodified":"2022-10-06T14:49:07.154768861Z","tags":null},"/note/SolidJS-Getting-Started":{"title":"","content":"# SolidJS - Getting Started\n\n\n## 참고 주소\nhttps://docs.solidjs.com/tutorials/getting-started-with-solid/installing-solid\n\n## 템플릿 설치\n```bash\nnpx degit solidjs/templates/ts my-app\ncd my-app\nnpm install # or yarn or pnpm\nnpm run dev # or yarn or pnpm\n```\n\n## 시작\n\nSolid 구조\n- index.html\n\t- Solid App(`Index.tsx`) 가 렌더링될 html\n\t- `index.tsx` 를 모듈로 import하는 구문이 body에 들어가야 함\n\t- div#root 가 body에 들어가야 함 (id 이름은 달라질 수 있으나 통상적으로 root)\n- index.tsx\n\t- main 역할\n- component (ex: App.tsx)\n\t- 인터페이스의 조각을 정의하는 함수\n\t- JSX 또는 TSX 반환\n\t- 컴포넌트는 하나의 최상위 HTML element를 리턴해야 함\n\t\t- 자식 Element는 몇 개를 가져도 상관 없음\n\t\t- JSX Fragment (`\u003c\u003e \u003c/\u003e`) 를 이용해서 감쌀 수 있음\n\n### Primitives\n\nComponent가 Solid 앱에서 view를 짓기 위한 블록이라면, Primitives는 반응성(interactivity)을 짓기 위한 블록이다. 처음으로 배울 primitive는 `signal`.\n\n```ts\nimport { createSignal, createEffect } from \"solid-js\";\nconst [count, setCount] = createSignal(0);\ncreateEffect(() =\u003e {\n  console.log(count());\n});\nsetCount(count() + 1);\n```\n\n1. state 변수를 만드는 것이 아니라, solid-js의 `createSignal`을 구조분해할당하여 `count`, `setCount` 를 생성함\n\t1. `createSignal(0)` 은 이 state 의 초기값이 0 임을 뜻함\n\t2. `count` 는 변수가 아니라 접근자(accessor, getter 라고도 부름) 함수임, state 그 자체가 오는 것이 아니라 현재의 state 값의 복사본을 가져온다- 즉 read-only 라고 생각\n\t3. `setCount` 는 setter 함수임.\n2. createEffect 는 시그널에 의존하는 사이드 이펙트를 생성함.\n\t1. 함수 내에서 참조한 시그널을 자동으로 추적(구독)함\n\t2. 주로 읽기만 하는 사이드 이펙트를 설정하는 것을 권장함\n\t\t1. 이펙트 내에서  시그널 쓰기를 하는 경우 추가 렌더링, 무한 루프 등의 문제를 겪을 수 있음\n\n시그널이 바뀌면, 해당 DOM 부분을 컨트롤하는 코드가 재실행된다. ","lastmodified":"2022-10-06T14:49:07.154768861Z","tags":null},"/note/SolidJS-Introduction-Basics":{"title":"","content":"# SolidJS - Introduction - Basics\n\u003c!--Basic Template V0.0.2 Start --\u003e\n```dataview\nTABLE WITHOUT ID  file.link AS title, tags\nFROM -\"templates\"\nSORT file.mtime, tags desc\nWHERE contains(tags, [[]])\n```\n\u003c!--Basic Template V0.0.2 End --\u003e\n[tags::[[SolidJS]]]\n\nhttps://www.solidjs.com/tutorial/introduction_basics\n\nSolid는 \n- 인터랙티브 웹 애플리케이션을 만들기 위한 자바스크립트 프레임워크\n- 기존 HTML 및 자바스크립트 지식을 사용해 앱 전체에서 재사용 가능한 컴포넌트를 빌드할 수 있음\n- 반응성[^반응성]을 사용해 컴포넌트를 향상시킬 수 있는 도구를 제공\n\n[^반응성]: 사용자 인터페이스와 데이터를 연결하는 선언적 자바스크립트 코드\n\t\n\tEvent(변경 사항의 전파 + 데이터 흐름) + 선언적 = 반응형 프로그래밍\n\n\t[프로그래밍 패러다임과 반응형 프로그래밍 그리고 Rx](https://velog.io/@teo/reactive-programming)\n\n모든 Solid 앱의 진입점은 `render` 함수다.\n\n```ts\nrender(() =\u003e \u003cHelloWorld /\u003e, document.getElementById('app'))\n```\n\n---\n\n\n\n## 문제\n\nTARGET DECK\n전체::개발::solid\n\n\u003c!--ankiQ--\u003e\n\n반응형 프로그래밍이란?\n\n\u003c!--ankiA--\u003e\n\n변경 사항의 전파 + 데이터 흐름 (via Event) 에 중점을 둔 선언적 프로그래밍 패러다임\n\n\u003c!--ankiE--\u003e\n\u003c!--ID: 1664943788324--\u003e\n\n\n\u003c!--ankiQ--\u003e\n\nSolid 앱의 진입점은?\n\n\u003c!--ankiA--\u003e\n\nrender\n\n\u003c!--ankiE--\u003e\n\u003c!--ID: 1664943788336--\u003e\n\n\n\u003c!--ankiQ--\u003e\n\nSolid 앱의 진입점을 render 함수로 잡으려고 한다.\n\n래핑 함수는 HelloWorld, 마운트할 대상 HTML 엘리먼트의 id는 'app' 일 때 render 함수를 작성하라.\n\n\u003c!--ankiA--\u003e\n\n`render(() =\u003e \u003cHelloWorld /\u003e, document.getElementById('app'))`\n\n\u003c!--ankiE--\u003e\n\u003c!--ID: 1664943788342--\u003e\n","lastmodified":"2022-10-06T14:49:07.154768861Z","tags":null},"/note/SolidJS-Introduction-Components":{"title":"","content":"# SolidJS - Introduction - Components\n\u003c!--Basic Template V0.0.2 Start --\u003e\n```dataview\nTABLE WITHOUT ID  file.link AS title, tags\nFROM -\"templates\"\nSORT file.mtime, tags desc\nWHERE contains(tags, [[]])\n```\n\u003c!--Basic Template V0.0.2 End --\u003e\n[tags::[[SolidJS]]]\n\nhttps://www.solidjs.com/tutorial/introduction_components\n\n코드를 컴포넌트 단위로 분리하면 모듈화와 재사용성을 챙길 수 있다.\n\n컴포넌트는 HelloWrold와 같은 함수이나, JSX를 반환하고, 다른 컴포넌트의 JSX에 의해 호출될 수 있다.\n\n```ts\nimport Nested from \"./nested\";\n\nfunction App() {\n  return (\n    \u003c\u003e\n      \u003ch1\u003eThis is a Header\u003c/h1\u003e\n      \u003cNested /\u003e\n    \u003c/\u003e\n  );\n}\n\n//./nested\nexport default () =\u003e \u003cp\u003eThis is a Paragraph\u003c/p\u003e\n```\n\n","lastmodified":"2022-10-06T14:49:07.154768861Z","tags":null},"/note/SolidJS-Introduction-Derived-Signals":{"title":"","content":"# SolidJS - Introduction - Derived Signals\n\u003c!--Basic Template V0.0.2 Start --\u003e\n```dataview\nTABLE WITHOUT ID  file.link AS title, tags\nFROM -\"templates\"\nSORT file.mtime, tags desc\nWHERE contains(tags, [[]])\n```\n\u003c!--Basic Template V0.0.2 End --\u003e\n[tags::[[SolidJS]]]\n\nhttps://www.solidjs.com/tutorial/introduction_derived\n\nDerived signals : 파생된 시그널\n\n시그널을 함수로 래핑하여 시그널에 의존하는 새로운 표현식을 생성할 수 있다. 시그널에 액세스하는 함수도 시그널이기 때문에, 래핑된 시그널이 변경되면 시그널에 의존하는 다른 시그널도 업데이트한다. 이를 파생된 시그널이라고 부른다.\n\n```ts\nconst doubleCount = () =\u003e count() * 2;\n```\n\n이렇게 count 시그널에 의존하는 새로운 표현식 doubleCount를 만들고,\n\n```ts\nreturn \u003cdiv\u003eCount: {doubleCount()}\u003c/div\u003e;\n```\n\nJSX에서 시그널처럼 doubleCount를 호출할 수 있다.\n\n","lastmodified":"2022-10-06T14:49:07.154768861Z","tags":null},"/note/SolidJS-Introduction-Effects":{"title":"","content":"# SolidJS - Introduction - Effects\n\u003c!--Basic Template V0.0.2 Start --\u003e\n```dataview\nTABLE WITHOUT ID  file.link AS title, tags\nFROM -\"templates\"\nSORT file.mtime, tags desc\nWHERE contains(tags, [[]])\n```\n\u003c!--Basic Template V0.0.2 End --\u003e\n[tags::[[SolidJS]]]\n\nhttps://www.solidjs.com/tutorial/introduction_effects\n\n시그널을 보완하기 위해, 추적 가능한 값으로 업데이트 할 수 있는 옵저버가 있다. 이펙트는 옵저버 중 하나로, 시그널에 의존하는 사이드 이펙트를 실행한다.\n\n`solid-js`에서 `createEffect`를 import해 이펙트를 생성할 수 있다. 이펙트는 함수가 실행되는 동안 읽은 모든 시그널을 자동으로 구독하고, 시그널이 변경되면 다시 실행된다.\n\ncount가 변경될 때마다 다시 실행되는 이펙트는 아래와 같다.\n\n```ts\ncreateEffect(() =\u003e {\n  console.log(\"The count is now\", count());\n});\n```\n\nEffect의 인자에 별도로 signal을 등록하는 부분이 없는 것을 확인할 수 있다. 위에서 말했듯 createEffect의 인자로 주어진 함수에서 `count()` 로 시그널을 받아오고, 이 부분을 createEffect가 읽고 count 시그널을 구독하게 된다.\n\n\ncreateEffect 로 만들어진 이펙트는 렌더링이 완료된 후 실행되며, 주로 DOM과 상호 작용하는 업데이트를 스케줄링하는 데 사용된다. DOM을 좀 더 일찍 수정하려면, [createRenderEffect](https://www.solidjs.com/docs/latest/api#createrendereffect)를 사용해야 한다(createEffect가 렌더링이 완료될 때까지 기다린 후에 실행된다면, createRenderEffect는 함수를 즉시 실행한다).\n\n---\n## 문제\n\nTARGET DECK\n전체::개발::solid\n\n\u003c!--ankiQ--\u003e\n\nsolid\n\ncount 시그널을 구독하여, 이를 console.log로 출력하는 effect를 생성하라.\n\n\u003c!--ankiA--\u003e\n\n```ts\ncreateEffect(() =\u003e {\n\tconsole.log(\"The count is now\", count());\n});\n```\n\n\u003c!--ankiE--\u003e\n\u003c!--ID: 1664945484877--\u003e\n\n\n\u003c!--ankiQ--\u003e\n\ncreateEffect 의 실행 시기는 주의해야 할 점이 있는데, 이것이 무엇이며, 대안은 무엇인가?\n\n\u003c!--ankiA--\u003e\n\ncreateEffect는 렌더링이 완료 된 후에 실행된다.\n\n렌더링 전에 즉시 실행하고 싶다면 createRenderEffect를 사용해야 한다.\n\n\u003c!--ankiE--\u003e\n\u003c!--ID: 1664945484881--\u003e\n","lastmodified":"2022-10-06T14:49:07.154768861Z","tags":null},"/note/SolidJS-Introduction-JSX":{"title":"","content":"# SolidJS - Introduction - JSX\n\u003c!--Basic Template V0.0.2 Start --\u003e\n```dataview\nTABLE WITHOUT ID  file.link AS title, tags\nFROM -\"templates\"\nSORT file.mtime, tags desc\nWHERE contains(tags, [[]])\n```\n\u003c!--Basic Template V0.0.2 End --\u003e\n[tags::[[SolidJS]]]\n\nhttps://www.solidjs.com/tutorial/introduction_jsx\n\nSolid는 JSX 를 사용한다. 다른 프레임워크와는 달리 가능한 한 HTML 표준에 가깝게 유지하려고 노력한다.\n\n하지만 JSX 가 HTML의 상위집합이 될 수는 없는데, 그 이유는 다음과 같다\n1. void 엘리먼트가 없다. 닫는 태그 또는 셀프 클로징을 해야 한다. `\u003cinput\u003e`, `\u003cbr\u003e` 엘리먼트를 복사할 때 특히 유의해야 한다.\n2. JSX는 단일 엘리먼트를 반환해야 한다. 여러 최상위 엘리먼트를 반환하고자 한다면 Fragment 엘리먼트를 사용해야 한다.\n3. JSX는 HTML 주석(`\u003c!-- --\u003e`)이나 `\u003c!DOCTYPE\u003e` 같은 특별한 태그를 지원하지 않는다.\n\n---\n\n## 문제\n\nTARGET DECK\n전체::개발::solid\n\n\u003c!--ankiQ--\u003e\n\nsolid는 void 엘리먼트가 없다. 이것이 의미하는 것은?\n\n\u003c!--ankiA--\u003e\n\n`\u003cinput\u003e`, `\u003cbr\u003e` 같은 엘리먼트를 복사할 때 닫는 태그 또는 셀프 클로징을 해야 함.\n\n\u003c!--ankiE--\u003e\n\u003c!--ID: 1664943671024--\u003e\n\n\n\u003c!--ankiQ--\u003e\n\nsolid에서 다음의 두 최상위 엘리먼트를 반환하고 싶다면 어떻게 해야겠는가?\n\n```ts\n  \u003ch1\u003eTitle\u003c/h1\u003e\n  \u003cp\u003eSome Text\u003c/p\u003e\n```\n\n\u003c!--ankiA--\u003e\n\nfragment 엘리먼트로 감싼다.\n\n```ts\n\u003c\u003e\n  \u003ch1\u003eTitle\u003c/h1\u003e\n  \u003cp\u003eSome Text\u003c/p\u003e\n\u003c/\u003e\n```\n\n\u003c!--ankiE--\u003e\n\u003c!--ID: 1664943850598--\u003e\n\n","lastmodified":"2022-10-06T14:49:07.154768861Z","tags":null},"/note/SolidJS-Introduction-Memos":{"title":"","content":"# SolidJS - Introduction - Memos\n\u003c!--Basic Template V0.0.2 Start --\u003e\n```dataview\nTABLE WITHOUT ID  file.link AS title, tags\nFROM -\"templates\"\nSORT file.mtime, tags desc\nWHERE contains(tags, [[]])\n```\n\u003c!--Basic Template V0.0.2 End --\u003e\n[tags::[[SolidJS]]]\n\nhttps://www.solidjs.com/tutorial/introduction_memos\n\n때로는 중복 작업을 줄이기 위해 값을 캐시할 필요가 있다. 이때 메모(Memo)를 사용하여 함수 실행 결과를 디펜던시가 변경될 때까지 캐시할 수 있다. 다른 디펜던시가 있는 이펙트에 대한 계산을 캐싱하고, DOM 노드 생성과 같은 값비싼 작업에 필요한 작업을 완화하는데 도움이 된다.\n\n메모는 이펙트와 같은 옵저버이면서, 읽기 전용 시그널이다. Memo는 자신의 디펜던시와 옵저버를 모두 알고 있기 때문에, 변경이 일어난 경우 한 번만 실행되도록 할 수 있다. _이 때문에 시그널에 이펙트 설정을 등록하는 것이 좋다._??\n\n`solid-js`에서 `createMemo`를 import하여 메모를 생성할 수 있다.\n\n```ts\nconst fib = () =\u003e fibonacci(count());\n\n  return (\n    \u003c\u003e\n      \u003cbutton onClick={() =\u003e setCount(count() + 1)}\u003eCount: {count()}\u003c/button\u003e\n      \u003cdiv\u003e1. {fib()} {fib()} {fib()} {fib()} {fib()}\u003c/div\u003e\n      \u003cdiv\u003e2. {fib()} {fib()} {fib()} {fib()} {fib()}\u003c/div\u003e\n      \u003cdiv\u003e3. {fib()} {fib()} {fib()} {fib()} {fib()}\u003c/div\u003e\n      \u003cdiv\u003e4. {fib()} {fib()} {fib()} {fib()} {fib()}\u003c/div\u003e\n      \u003cdiv\u003e5. {fib()} {fib()} {fib()} {fib()} {fib()}\u003c/div\u003e\n      \u003cdiv\u003e6. {fib()} {fib()} {fib()} {fib()} {fib()}\u003c/div\u003e\n      \u003cdiv\u003e7. {fib()} {fib()} {fib()} {fib()} {fib()}\u003c/div\u003e\n      \u003cdiv\u003e8. {fib()} {fib()} {fib()} {fib()} {fib()}\u003c/div\u003e\n      \u003cdiv\u003e9. {fib()} {fib()} {fib()} {fib()} {fib()}\u003c/div\u003e\n      \u003cdiv\u003e10. {fib()} {fib()} {fib()} {fib()} {fib()}\u003c/div\u003e\n    \u003c/\u003e\n  );\n```\n\n위의 반환문은 파생된 시그널인 fib 를 50번 불러오고 있다. fib는 count를 구독하고 있어, count 시그널이 변경될 때마다 fib가 50번 실행될 것이다. 이때 연산을 줄이기 위해 memo로 값을 캐싱하여, count 시그널이 업데이트 된 최초의 1번에만 계산되고 나머지는 캐싱된 값을 쓰도록 할 수 있다.\n\n```ts\nconst fib = createMemo(() =\u003e fibonacci(count()));\n```\n\n---\n\n## 문제\n\nTARGET DECK\n전체::개발::solid\n\n\u003c!--ankiQ--\u003e\n\n```ts\nconst fib = () =\u003e fibonacci(count());\n```\n\n위 함수는 count 시그널을 구독하고 있는데, fib 함수를 이곳 저곳에서 굉장히 많이 불러 중복 연산되고 있다.\n\ncount 시그널이 업데이트 된 최초의 1번에만 계산하고 그 뒤로는 처음 계산 값을 그대로 사용해도 된다면, 코드를 어떻게 수정하여 중복 연산을 줄일 수 있겠는가?\n\n\u003c!--ankiA--\u003e\n\n```ts\nconst fib = createMemo(() =\u003e fibonacci(count()));\n```\n\n\u003c!--ankiE--\u003e\n\u003c!--ID: 1664946251797--\u003e\n","lastmodified":"2022-10-06T14:49:07.154768861Z","tags":null},"/note/SolidJS-Introduction-Signals":{"title":"","content":"# SolidJS - Introduction - Signals\n\u003c!--Basic Template V0.0.2 Start --\u003e\n```dataview\nTABLE WITHOUT ID  file.link AS title, tags\nFROM -\"templates\"\nSORT file.mtime, tags desc\nWHERE contains(tags, [[]])\n```\n\u003c!--Basic Template V0.0.2 End --\u003e\n[tags::[[SolidJS]]]\n\nhttps://www.solidjs.com/tutorial/introduction_signals\n\nSignal은 변경되는 값을 포함한다. 시그널의 값을 변경하면, 해당 시그널을 사용하는 모든 것들이 자동으로 업데이트 된다. 즉, 시그널 값의 변경이 시그널을 구독한 요소들에 전파되므로 반응성의 토대가 된다고 말할 수 있다.\n\n시그널을 생성하려면, `solid-js` 에서 `createSignal` 을 import 해야 한다.\n\n```ts\nconst [count, setCount] = createSignal(0);\n```\ncount는 getter, setCount는 setter, createSignal 의 인자인 0 은 초기값을 의미한다. createSignal의 첫번째 반환값인 count가 변수가 아니라 값을 반환하는 함수임에 유의한다.\n\nJSX에서 count 를 이용하여 값을 받아오는 부분은, 추후에 setCount로 시그널의 값이 변경되었을 때 업데이트 된다.\n\n---\n\n## 문제\n\nTARGET DECK\n전체::개발::solid\n\n\u003c!--ankiQ--\u003e\n\n1/ solid의 signal 을 만들어라.\n\ngetter 의 이름은 count,\n\nsetter의 이름은 setCount,\n\n시그널의 초기값은 0.\n\n2/ setInterval을 이용하여 count 시그널의 값을 매초마다 1씩 증가하게 하라.\n\n\u003c!--ankiA--\u003e\n\n```ts\nconst [count, setCount] = createSignal(0);\nsetInterval(() =\u003e setCount(count()+1), 1000);\n```\n\n\u003c!--ankiE--\u003e\n\u003c!--ID: 1664944861074--\u003e\n","lastmodified":"2022-10-06T14:49:07.154768861Z","tags":null},"/note/SolidJS-Lifecycles-onCleanup":{"title":"","content":"# SolidJS - Lifecycles - onCleanup\n\u003c!--Basic Template V0.0.2 Start --\u003e\n```dataview\nTABLE WITHOUT ID  file.link AS title, tags\nFROM -\"templates\"\nSORT file.mtime, tags desc\nWHERE contains(tags, [[]])\n```\n\u003c!--Basic Template V0.0.2 End --\u003e\n[tags::[[SolidJS]]]\n\nhttps://www.solidjs.com/tutorial/lifecycles_oncleanup\n\nonCleanup 함수는 이펙트, 컴포넌트, 커스텀 디렉티브 뿐만 아니라 리액티브 시스템의 동기 실행이 일어나는 거의 모든 곳에서 사용할 수 있다. 해당 스코프가 재평가를 위해 트리거되고 최종적으로 폐기될 때 실행된다.\n\n```tsx\nconst timer = setInterval(() =\u003e setCount(count() + 1), 1000);\nonCleanup(() =\u003e clearInterval(timer));\n```","lastmodified":"2022-10-06T14:49:07.154768861Z","tags":null},"/note/SolidJS-Lifecycles-onMount":{"title":"","content":"# SolidJS - Lifecycles - onMount\n\u003c!--Basic Template V0.0.2 Start --\u003e\n```dataview\nTABLE WITHOUT ID  file.link AS title, tags\nFROM -\"templates\"\nSORT file.mtime, tags desc\nWHERE contains(tags, [[]])\n```\n\u003c!--Basic Template V0.0.2 End --\u003e\n[tags::[[SolidJS]]]\n\nhttps://www.solidjs.com/tutorial/lifecycles_onmount\n\nonMount는 초기 렌더링이 완료되면 컴포넌트 당 한 번만 실행된다.\n\n라이프사이클은 브라우저에서만 실행되므로, onMount에 있는 코드는 SSR 동산 서버에서 실행되지 않는다.\n\n```tsx\nconst [photos, setPhotos] = createSignal([]);\nonMount(async () =\u003e {\n  const res = await fetch(`https://jsonplaceholder.typicode.com/photos?_limit=20`);\n  setPhotos(await res.json());\n});\n```\n","lastmodified":"2022-10-06T14:49:07.154768861Z","tags":null},"/note/SolidJS-Props-Children":{"title":"","content":"# SolidJS - Props - Children\n\u003c!--Basic Template V0.0.2 Start --\u003e\n```dataview\nTABLE WITHOUT ID  file.link AS title, tags\nFROM -\"templates\"\nSORT file.mtime, tags desc\nWHERE contains(tags, [[]])\n```\n\u003c!--Basic Template V0.0.2 End --\u003e\n[tags::[[SolidJS]]]\n\nhttps://www.solidjs.com/tutorial/props_children\n\nchildren 헬퍼에 대한 내용은 튜토리얼이 매우 빈약하기 때문에 [영문 api 문서](https://www.solidjs.com/docs/latest/api#children)를 참고하십시오. (한국어 api 문서는 업데이트 되지 않았음)\n\nSolid의 성능을 높이는 부분 중 하나는 컴포넌트가 기본적으로 함수 호출이기 때문이다. 컴파일러가 객체의 getter 안에서 잠재적으로 리액티브한 표현식을 래핑하는 방식으로 업데이트를 전파한다. 컴파일 결과를 다음과 같이 그려볼 수 있다.\n\n```tsx\n// 이 JSX 표현식이\n\u003cMyComp dynamic={mySignal()}\u003e\n  \u003cChild /\u003e\n\u003c/MyComp\u003e\n\n// 이렇게 컴파일됩니다.\nMyComp({\n  get dynamic() { return mySignal() },\n  get children() { return Child() }\n});\n```\n\n이는 props가 지연 평가됨을 의미한다. props에 대한 액세스는 사용될 때까지 연기된다. 이로 인해 추가 래퍼나 동기화를 도입하지 않으면서도 반응성을 유지할 수 있다.\n\n하지만 이는 동시에 props 에 재차 액세스하는 것은 자식 컴포넌트나 엘리먼트가 다시 생성될 수도 있음을 의미한다.\n\n`props.children` 은 해당 엘리먼트의 자식 엘리먼트들을 나타내는 속성이다.  정확히 말하자면 자식 엘리먼트라는 시그널의 getter 다. props.children 에 접근할 때마다 자식이 중복해서 생기는데, 자식을 의도적으로 중복 생성하는 경우 이 동작이 도움이 되겠지만 대부분의 경우 의도하지 않게 자식 노드를 중복으로 만들어 성능 저하를 유발하는 경우가 많다.\n\n이러한 이유로, Solid는 `children` 헬퍼를 제공한다. 이 메서드는 `children` prop에 대해 memo를 생성하고, 자식과 직접 인터랙션을 할 수 있도록 중첩된 자식들에 대해서도 리액티브한 참조를 제공한다.\n\n아래 예시를 통해 props.children 과 children 헬퍼에 대해 어느 정도 감을 잡을 수 있다.\n\n\n```tsx\n//main.jsx\nimport { render } from \"solid-js/web\";\nimport { createSignal, For } from \"solid-js\";\n\nimport ColoredList from \"./colored-list\";\n\nfunction App() {\n  const [color, setColor] = createSignal(\"purple\");\n  const [child, setChild] = createSignal([\"Most\", \"Interesting\", \"Thing\"]);\n  setTimeout(()=\u003e{setChild([...child(), \"?\"])}, 3000);\n  return \u003c\u003e\n    \u003cColoredList color={color()}\u003e\n      \u003cFor each={child()}\u003e{item =\u003e \u003cdiv\u003e{item}\u003c/div\u003e}\u003c/For\u003e\n    \u003c/ColoredList\u003e\n    \u003cbutton onClick={() =\u003e setColor(\"teal\")}\u003eSet Color\u003c/button\u003e\n  \u003c/\u003e;\n}\n\nrender(() =\u003e \u003cApp /\u003e, document.getElementById('app'));\n```\n\nmain.jsx에서는 ColoredList의 자식을 For 컴포넌트로 생성하는데, 이때 For 컴포넌트의 each 속성에 child 시그널을 달았다. 3초 후에 child 시그널의 값인 배열에 \"?\" 가 추가되는데, 이는 colored-list.jsx 에서 자식에 대한 반응성을 보기 위함이다.\n\n```tsx\n//colored-list.jsx\nimport { createEffect, children } from \"solid-js\";\n\nexport default function ColoredList(props) {\n  const c = children(() =\u003e props.children);\n  const c2 = props.children();\n  const c3 = props.children;\n  \n  createEffect(() =\u003e c().forEach(item =\u003e item.style.color = props.color));\n  createEffect(()=\u003e c2.forEach(item =\u003e item.style.color = props.color == \"purple\" ? props.color : 'gray'));\n  createEffect(()=\u003e c3().forEach(item =\u003e item.style.color = props.color == \"purple\" ? props.color : 'gray'));\n  \n  return \u003c\u003e{c()}{c2}{c3()}{props.children}\u003c/\u003e\n}\n```\n\nColoredList 는 fragment 컴포넌트로 묶어 `c()`, `c2`, `c3()`, `props.children` 을 반환하고 있다.\n\n- `c()`\n\t- 가장 이상적인 방법으로, `children` 헬퍼를 이용하여 props.children 으로 생성된 노드들을 재사용하고 있다.\n\t- props.children의 변경에 반응한다.\n\t- props.color의 변경에 반응한다.\n- `c2`\n\t- props.children() 으로 생성된 노드들을 보관하고 있다.\n\t- props.children의 변경에 반응하지 않는다.\n\t- props.color의 변경에 반응한다.\n- `c3()`\n\t- props.children의 변경에 반응한다.\n\t- props.color의 변경에 반응한다.\n- `props.children`\n\t- props.children의 변경에 반응한다.\n\t- props.color의 변경에 반응하지 않는다.\n\n`children` 헬퍼는 자식의 수에 따라 반환 형태가 다르다.\n- 2개 이상 : Array\n- 1개 : function\n- 0개 : null\n- 만약 무조건 배열로 노멀라이즈하고 싶다면 `c()` 가 아니라 `c.toArray()` 와 같이 사용해야 한다\n\n```tsx\nconst Wrapper = (props) =\u003e {\n  return \u003cdiv\u003e{props.children}\u003c/div\u003e;\n};\n```\n\n위 케이스와 같이 `props.children` 을 그대로 통과시키는 경우는 굳이 children 헬퍼를 이용할 필요가 없다.\n\n```tsx\nimport { createEffect, children } from \"solid-js\";\n\nexport default function ColoredList(props) {\n  const c = children(() =\u003e props.children);\n  createEffect(() =\u003e c().forEach(item =\u003e item.style.color = props.color));\n  return \u003c\u003e{c()}\u003c/\u003e\n}\n```\n\nchildren 헬퍼의 중요한 부분은 props.children에 즉시 접근하기 때문에 생성되도록 강요한다는 것이다. 이는 자식을 조건부 렌더링해야 되는 경우 바람직하지 않다. \n\n```tsx\nconst resolved = children(() =\u003e props.children);\n\nreturn \u003cShow when={visible()}\u003e{resolved()}\u003c/Show\u003e;\n```\n\nShow 조건이 충족될 때만 자식을 평가하고 싶다면 아래와 같이 수정하면 된다.\n\n```tsx\nconst resolved = children(() =\u003e visible() \u0026\u0026 props.children);\n```\n\n## 문제\n\nTARGET DECK\n전체::개발::solid\n\n---\n\n\u003c!--ankiQ--\u003e\n\nSolid의 `props.children` 은 접근할 때마다 새로운 노드가 중복 생성된다. 자식과 직접 인터랙션을 하면서도 리액티브한 참조를 얻기 위해서 사용하는 기능은 무엇인가?\n\n사용 예시를 들라.\n\n\u003c!--ankiA--\u003e\n\n```tsx\nconst c = children(()=\u003eprops.children);\n```\n\n`children` 헬퍼.\n\n\u003c!--ankiE--\u003e\n\u003c!--ID: 1664976941767--\u003e\n\n---\n\n\u003c!--ankiQ--\u003e\n\n```tsx\n//main.jsx\nimport { render } from \"solid-js/web\";\nimport { createSignal, For } from \"solid-js\";\n\nimport ColoredList from \"./colored-list\";\n\nfunction App() {\n  const [color, setColor] = createSignal(\"purple\");\n  const [child, setChild] = createSignal([\"Most\", \"Interesting\", \"Thing\"]);\n  setTimeout(()=\u003e{setChild([...child(), \"?\"])}, 3000);\n  return \u003c\u003e\n    \u003cColoredList color={color()}\u003e\n      \u003cFor each={child()}\u003e{item =\u003e \u003cdiv\u003e{item}\u003c/div\u003e}\u003c/For\u003e\n    \u003c/ColoredList\u003e\n    \u003cbutton onClick={() =\u003e setColor(\"teal\")}\u003eSet Color\u003c/button\u003e\n  \u003c/\u003e;\n}\n\nrender(() =\u003e \u003cApp /\u003e, document.getElementById('app'));\n```\n\n```tsx\n//colored-list.jsx\nimport { createEffect, children } from \"solid-js\";\n\nexport default function ColoredList(props) {\n  const c = children(() =\u003e props.children);\n  const c2 = props.children();\n  const c3 = props.children;\n  \n  createEffect(() =\u003e c().forEach(item =\u003e item.style.color = props.color));\n  createEffect(()=\u003e c2.forEach(item =\u003e item.style.color = props.color == \"purple\" ? props.color : 'gray'));\n  createEffect(()=\u003e c3().forEach(item =\u003e item.style.color = props.color == \"purple\" ? props.color : 'gray'));\n  \n  return \u003c\u003e{c()}{c2}{c3()}{props.children}\u003c/\u003e\n}\n```\n\n위 Solid 코드는 props.children 과 children 헬퍼의 차이를 파악하기 위해 작성되었다.\n\nColoredList 가 반환하는 fragment 엘리먼트 내부는 props.children과 props.color에 반응성을 가질 수 있다. 각각의 결과를 예상하라.\n\n\u003c!--ankiA--\u003e\n\n||c()|c2|c3()|props.children|\n---|---|---|---|---\nprops.children|O|X|O|O\nprops.color|O|O|O|X\n\n\u003c!--ankiE--\u003e\n\u003c!--ID: 1664976941790--\u003e\n\n---\n\n\u003c!--ankiQ--\u003e\n\n```tsx\nconst resolved = children(() =\u003e props.children);\n\nreturn \u003cShow when={visible()}\u003e{resolved()}\u003c/Show\u003e;\n```\n\n현재는 Show 조건과 상관 없이 props.children 이 평가된다.\n\nShow 컴포넌트의 조건이 충족될 때 props.children 이 평가되게끔 하려면 어떻게 해야겠는가?\n\n\u003c!--ankiA--\u003e\n\napi)\n\n```tsx\nconst resolved = children(() =\u003e visible() \u0026\u0026 props.children);\n```\n\n실제로는 false가 반환되는 문제가 있어 resolved.toArray를 걸어도  오류가 발생하는 문제가 있다.\n\n```tsx\nconst resolved = children(() =\u003e visible() ? props.children : []);\n```\n\n위와 같이 적용해야 의도한 대로 동작한다.\n\n\u003c!--ankiE--\u003e\n\u003c!--ID: 1664976941795--\u003e\n","lastmodified":"2022-10-06T14:49:07.154768861Z","tags":null},"/note/SolidJS-Props-Default-Props":{"title":"","content":"# SolidJS - Props - Default Props\n\u003c!--Basic Template V0.0.2 Start --\u003e\n```dataview\nTABLE WITHOUT ID  file.link AS title, tags\nFROM -\"templates\"\nSORT file.mtime, tags desc\nWHERE contains(tags, [[]])\n```\n\u003c!--Basic Template V0.0.2 End --\u003e\n[tags::[[SolidJS]]]\n\nhttps://www.solidjs.com/tutorial/props_defaults\n\nProps는 JSX에 바인딩된 모든 속성을 나타내는, 실행시 컴포넌트 함수에 전달되는 객체다. Props 객체는 읽기 전용이며, Object getter로 래핑된 리액티브 프로퍼티를 갖는다. 이를 통해 호출자가 시그널이나 시그널 표현식, 정적인 값을 사용했는지 여부와 관계없이 props.propName 과 같은 일관된 형식으로 액세스할 수 있다.\n\n트래킹 스코프 밖에서 props 객체를 디스트럭처링하면서 반응성을 잃을 수 있기 때문에, 디스트럭처링을 사용하지 않는 것이 중요하다. 일반적으로 Solid의 프리미티브나 JSX 밖에서 props 객체의 프로퍼티에 액세스하면 반응성을 잃을 수 있다. 이는 디스트럭처링 뿐만 아니라 스프레드 연산자, Object.assign과 같은 함수에도 적용된다.\n\nSolid는 props를 사용할 때 도움이 되는 몇 가지 유틸리티를 제공한다.\n- mergeProps\n\t- 반응성을 잃지 않고 리액티브 객체를 머지(비파괴적인 Object.assgin)할 수 있다.\n\t- 컴포넌트의 디폴트 props를 설정할 때 일반적으로 많이 사용한다.\n\n```tsx\nexport default function Greeting(props) {\n  return \u003ch3\u003e{props.greeting || \"Hi\"} {props.name || \"John\"}\u003c/h3\u003e\n}\n```\n\n위의 코드를 mergeProps를 이용하여\n\n```tsx\nimport { mergeProps } from \"solid-js\";\n\nexport default function Greeting(props) {\n  const merged = mergeProps({ greeting: \"Hi\", name: \"John\" }, props);\n\n  return \u003ch3\u003e{merged.greeting} {merged.name}\u003c/h3\u003e\n}\n```\n\n이렇게 수정할 수 있다. \n\n```tsx\nexport default function Greeting(props) {\n  const merged = {  greeting: \"Hi\", name: \"John\", ...props };\n\n  return \u003ch3\u003e{merged.greeting} {merged.name}\u003c/h3\u003e\n}\n```\n\n위 케이스의 경우 props를 디스트럭처링하여 반응성을 잃는다. props가 변동되더라도 재 렌더링 되지 않는다.\n\n## 문제\n\nTARGET DECK\n전체::개발::solid\n\n---\n\n\u003c!--ankiQ--\u003e\n\n```tsx\nexport default function Greeting(props) {\n  return \u003ch3\u003e{props.greeting || \"Hi\"} {props.name || \"John\"}\u003c/h3\u003e\n}\n```\n\n위 Solid 코드는 props의 기본 값을 지정하기 위해 템플릿에 인라인으로 지정했다. 하지만 props.greeting 등의 값이 여기 저기서 쓰여야 한다면 인라인 지정은 코드를 굉장히 난잡하게 만든다.\n\nSolid에서는 이러한 경우를 위해, 반응성을 잃지 않고 리액티브 객체를 머지할 수 있는 유틸리티를 제공한다. 이를 제공하여 위 코드를 수정하라.\n\n\u003c!--ankiA--\u003e\n\n```tsx\nimport { mergeProps } from \"solid-js\";\n\nexport default function Greeting(props) {\n  const merged = mergeProps({ greeting: \"Hi\", name: \"John\" }, props);\n\n  return \u003ch3\u003e{merged.greeting} {merged.name}\u003c/h3\u003e\n}\n```\n\n\u003c!--ankiE--\u003e\n\u003c!--ID: 1664967175913--\u003e\n\n\n---\n\n\u003c!--ankiQ--\u003e\n\n```tsx\nexport default function Greeting(props) {\n  const merged = {  greeting: \"Hi\", name: \"John\", ...props };\n\n  return \u003ch3\u003e{merged.greeting} {merged.name}\u003c/h3\u003e\n}\n```\n\n위 Solid 코드는 어떤 위험성을 내포하고 있는가?\n\n\u003c!--ankiA--\u003e\n\nprops를 트래킹 스코프 바깥에서 디스트럭처링하여 반응성을 잃는다. 즉, props가 시그널 등으로 업데이트되더라도 재 렌더링되지 않을 것이다.\n\n\u003c!--ankiE--\u003e\n\u003c!--ID: 1664967175930--\u003e\n","lastmodified":"2022-10-06T14:49:07.154768861Z","tags":null},"/note/SolidJS-Props-Splitting-Props":{"title":"","content":"# SolidJS - Props - Splitting Props\n\u003c!--Basic Template V0.0.2 Start --\u003e\n```dataview\nTABLE WITHOUT ID  file.link AS title, tags\nFROM -\"templates\"\nSORT file.mtime, tags desc\nWHERE contains(tags, [[]])\n```\n\u003c!--Basic Template V0.0.2 End --\u003e\n[tags::[[SolidJS]]]\n\nhttps://www.solidjs.com/tutorial/props_split\n\nprops를 그룹으로 나누어 현재 컴포넌트에서 일부 사용하고, 나머지는 자식 컴포넌트로 전달하고 싶은 경우가 있다.\n\n```tsx\nexport default function Greeting(props) {\n  const { greeting, name, ...others } = props;\n  return \u003ch3 {...others}\u003e{greeting} {name}\u003c/h3\u003e\n}\n```\n\n위와 같이 디스트럭처링을 이용하면 반응성을 잃어 이름을 설정하더라도 업데이트되지 않는다.\n\n대신 splitProps를 사용하면 반응성을 유지할 수 있다.\n\n```tsx\nexport default function Greeting(props) {\n  const [local, others] = splitProps(props, [\"greeting\", \"name\"]);\n  return \u003ch3 {...others}\u003e{local.greeting} {local.name}\u003c/h3\u003e\n}\n```\n\n- props 객체와 추출하려는 하나 이상의 키 배열을 인수로 받는다.\n- 함수의 반환값을 props 객체의 배열\n\t- 첫번째 원소는 추출한 키들로 구성된 props 객체\n\t- 두번째 원소는 추출하고 남은 키들로 구성된 props 객체\n\t- 둘 다 반응성을 유지함\n\n## 문제\n\nTARGET DECK\n전체::개발::solid\n\n---\n\n\u003c!--ankiQ--\u003e\n\n```tsx\nexport default function Greeting(props) {\n  const { greeting, name, ...others } = props;\n  return \u003ch3 {...others}\u003e{greeting} {name}\u003c/h3\u003e\n}\n```\n\n위 Solid 코드는 Greeting 컴포넌트의 props를 greeting, name과 나머지 키들로 쪼개 , 나머지 키들을 h3 컴포넌트에 전달하려는 목적을 가지고 있다.\n\n하지만 구조분해할당을 하면서 반응성을 잃은 상태인데, 어떻게 수정하면 반응성을 유지하면서 props를 분리할 수 있는가?\n\n\u003c!--ankiA--\u003e\n\n```tsx\nimport { splitProps } from \"solid-js\";\n\nexport default function Greeting(props) {\n  const [local, others] = splitProps(props, [\"greeting\", \"name\"]);\n  return \u003ch3 {...others}\u003e{local.greeting} {local.name}\u003c/h3\u003e\n}\n```\n\n\u003c!--ankiE--\u003e\n\u003c!--ID: 1664967738921--\u003e\n","lastmodified":"2022-10-06T14:49:07.154768861Z","tags":null},"/note/SolidJS-Reactivity-Batching-Updates":{"title":"","content":"# SolidJS - Reactivity - Batching Updates\n\n\u003c!--Basic Template V0.0.2 Start --\u003e\n```dataview\nTABLE WITHOUT ID  file.link AS title, tags\nFROM -\"templates\"\nSORT file.mtime, tags desc\nWHERE contains(tags, [[]])\n```\n\u003c!--Basic Template V0.0.2 End --\u003e\n[tags::[[SolidJS]]]\n\nhttps://www.solidjs.com/tutorial/reactivity_batch\n\nSolid의 반응성은 동기식이다. 즉, 변경이 일어나면 다음 행에서 DOM이 업데이트된다는 뜻이다. Solid의 세분화된 렌더링은 리액티브 시스템에서 발생한 업데이트를 전파할 뿐이므로 대부분의 경우 이는 문제가 없다. 관련없는 변경 사항을 두 번 \"렌더링\" 한다고 해서, 실제로 쓸데없는 작업이 낭비되는 것은 아니다.\n\n만일 변경 사항이 서로 관련되어 있으면 어떻게 될까? Solid의 batch 헬퍼를 사용하게 되면 여러 변경 사항을 대기열에 넣은 다음, 옵저버에 알리기 전에 모두 동시에 적용할 수 있다. 배치 내에서 업데이트된 시그널 값은 완료될 때까지 커밋되지 않는다.\n\n```tsx\nconsole.log(\"Button Clicked\");\nsetFirstName(firstName() + \"n\");\nsetLastName(lastName() + \"!\");\n```\n\nfirstName, lastName 시그널의 변경이 같은 엘리먼트를 렌더링을 다시 하게 만드는 반응성을 갖고 있다면, 위의 구문을 실행하면 해당 엘리먼트는 두 번 렌더링 될 것이다.\n\n```tsx\nconsole.log(\"Button Clicked\");\nbatch(() =\u003e {\n\tsetFirstName(firstName() + \"n\");\n\tsetLastName(lastName() + \"!\");\n})\n```\n\n위와 같이 batch 를 활용하면 렌더링은 한번만 될 것이다.\n\n## 문제\n\nTARGET DECK\n전체::개발::solid\n\n---\n\n\u003c!--ankiQ--\u003e\n\n```tsx\nsetFirstName(firstName() + \"n\");\nsetLastName(lastName() + \"!\");\n```\n\n위 Solid 코드의 firstName, lastName은 시그널이다. 이대로 실행한다면 FirstName의 변경이 전파된 후 LastName의 변경이 전파될 것이다. 위 두 시그널의 전파를 동시에 발생시키고 싶은 경우 어떻게 해야겠는가?\n\n\u003c!--ankiA--\u003e\n\n```tsx\nbatch(() =\u003e {\n\tsetFirstName(firstName() + \"n\");\n\tsetLastName(lastName() + \"!\");\n})\n```\n\nbatch 사용.\n\n\u003c!--ankiE--\u003e\n\u003c!--ID: 1665048202080--\u003e\n","lastmodified":"2022-10-06T14:49:07.154768861Z","tags":null},"/note/SolidJS-Reactivity-Lazy-Components":{"title":"","content":"# SolidJS - Reactivity - Lazy Components\n\n\u003c!--Basic Template V0.0.2 Start --\u003e\n```dataview\nTABLE WITHOUT ID  file.link AS title, tags\nFROM -\"templates\"\nSORT file.mtime, tags desc\nWHERE contains(tags, [[]])\n```\n\u003c!--Basic Template V0.0.2 End --\u003e\n[tags::[[SolidJS]]]\n\nhttps://www.solidjs.com/tutorial/async_lazy\n\n이 내용은 code splitting에 대한 이해가 필요하다.\n\n대부분의 번들러는 동적 임포트를 사용하는 경우 자동으로 코드 분할을 처리한다. Solid의 Lazy 메서드를 사용하면 지연된 로딩을 위해 컴포넌트의 동적 임포넌트를 래핑할 수 있다. 반환값은 JSX에서 사용할 수 있는 컴포넌트다.\n\n다만 처음 렌더링될 때 내부적으로는 임포트한 코드를 동적으로 로드하여, 코드를 사용할 수 있을 때까지 해당 렌더링 분기를 중지한다.\n\n```tsx\nimport Greeting from \"./greeting\";\n```\n\n위와 같은 임포트를\n\n```tsx\nconst Greeting = lazy(() =\u003e import(\"./greeting\"));\n```\n\n위와 같이 lazy 메서드로 변경할 수 있다.\n\n```tsx\nconst Greeting = lazy(async () =\u003e {\n  await new Promise(r =\u003e setTimeout(r, 1000));\n  return import(\"./greeting\")\n});\n```\n\n눈으로 확인하기 위해 억지로 딜레이를 추가하면 지연 컴포넌트가 늦게 렌더링되는 것을 확인할 수 있다.\n\n## 문제\n\nTARGET DECK\n전체::개발::solid\n\n---\n\n\u003c!--ankiQ--\u003e\n\n```tsx\nimport Greeting from \"./greeting\";\n```\n\n위 import 를 lazy 컴포넌트로 변경하라.\n\n\u003c!--ankiA--\u003e\n\n```tsx\nconst Greeting = lazy(() =\u003e import(\"./greeting\"));\n```\n\n\u003c!--ankiE--\u003e\n\u003c!--ID: 1665054490931--\u003e\n","lastmodified":"2022-10-06T14:49:07.154768861Z","tags":null},"/note/SolidJS-Reactivity-On":{"title":"","content":"# SolidJS - Reactivity - On\n\n\u003c!--Basic Template V0.0.2 Start --\u003e\n```dataview\nTABLE WITHOUT ID  file.link AS title, tags\nFROM -\"templates\"\nSORT file.mtime, tags desc\nWHERE contains(tags, [[]])\n```\n\u003c!--Basic Template V0.0.2 End --\u003e\n[tags::[[SolidJS]]]\n\nhttps://www.solidjs.com/tutorial/reactivity_on\n\nhttps://www.solidjs.com/docs/latest/api#on\n\n편의를 위해 Solid는 계산에 필요한 디펜던시를 명시적으로 설정할 수 있도록 on 헬퍼를 제공한다.\n\n이는 주로 어떤 시그널이 추적되는지에 대한 명시적이고 간결한 방법으로 사용된다. 다른 시그널들을 읽더라도 기재되지 않았다면 추적하지 않는다.\n\n```tsx\ncreateEffect(on(a, (a) =\u003e {\n  console.log(a, b());\n}, { defer: true }));\n```\n\n추가로 on은 defer 옵션을 제공하는데, 이를 사용하면 계산이 즉시 실행되지 않고 (시그널 값을 초기화할 때도 이펙트가 즉시 실행되는데 이를 무시하고) 첫번째 변경시에만 실행되도록 할 수 있다.\n\n```tsx\ncreateEffect(on([a, b], () =\u003e {\n\tconsole.log(a(), b());\n}, {defer: false}));\n\ncreateEffect(on([a, b], ([_a, _b]) =\u003e {\n\tconsole.log(_a, _b);\n}, {defer: false}));\n```\n\n## 문제\n\nTARGET DECK\n전체::개발::solid\n\n---\n\n\u003c!--ankiQ--\u003e\n\nSolid의 effect 에 필요한 디펜던시를 명시적으로 설정하려면 어떤 것을 사용해야 하는가?\n\n\u003c!--ankiA--\u003e\n\non\n\n```tsx\ncreateEffect(on(a, (a) =\u003e {\n  console.log(a, b());\n}, { defer: true }));\n```\n\n\u003c!--ankiE--\u003e\n\u003c!--ID: 1665050636459--\u003e\n","lastmodified":"2022-10-06T14:49:07.154768861Z","tags":null},"/note/SolidJS-Reactivity-Resources":{"title":"","content":"# SolidJS - Reactivity - Resources\n\n\u003c!--Basic Template V0.0.2 Start --\u003e\n```dataview\nTABLE WITHOUT ID  file.link AS title, tags\nFROM -\"templates\"\nSORT file.mtime, tags desc\nWHERE contains(tags, [[]])\n```\n\u003c!--Basic Template V0.0.2 End --\u003e\n[tags::[[SolidJS]]]\n\nhttps://www.solidjs.com/tutorial/async_resources\n\nhttps://www.solidjs.com/docs/latest/api#createresource\n\nResource는 비동기 로딩을 처리하도록 특별히 설계된 특수 시그널이다. 그 목적은 Solid의 분산 실행 모델과 쉽게 상호 작용할 수 있도록 비동기 값을 래핑하는 것이다.\n\n이는 async/await 또는 순차 실행 모델을 제공하는 제너레이터와는 정반대다. 목표는 비동기 작업으로 실행을 중단하지 않고, 코드를 덧붙이지 않는 것이다.\n\nResource는 Promise를 반환하는 비동기 데이터 fetch 함수를 퀄히ㅏ는 소스 시그널에 의해 구동될 수 있다. fetch 함수의 내용은 무엇이든 가능하다. 일반 REST 엔드포인트나 GraphQL 호출처럼 Promise를 생성하는 모든 것을 할 수 있다. Resource는 데이터 로딩 방법에 좌우되지 않으며, Promise에 의해서만 구동된다.\n\nResource 시그널의 결과에는 현재 상태를 기반으로 View를 쉽게 컨트롤할 수 있도록 하는 반응형 loading과 error 프로퍼티도 포함된다.\n\n```tsx\nconst fetchUser = async (id) =\u003e\n  (await fetch(`https://swapi.dev/api/people/${id}/`)).json();\nconst [userId, setUserId] = createSignal();\nconst [user, { mutate, refetch }] = createResource(userId, fetchUser);\n```\n\nuserId, setUserId 는 검색 대상인 user의 ID 변화를 감지하는 시그널이다.\n\n`setUserId(id)` -\u003e `createResource`에 등록된 `userId` -\u003e `createResource`에 등록된 `fetchUser(id)` -\u003e `user()` 로 사용\n\n과 같은 과정을 거친다.\n\ncreateResource에서 반환되는 2번째 값에는 내부 시그널을 직접 업데이트하는 `mutate` 메서드와, 소스가 변경되지 않은 경우에도 현재 쿼리를 다시 로드하는 `refetch` 메서드가 포함되어 있다.\n\n## 문제\n\nTARGET DECK\n전체::개발::solid\n\n---\n\n\u003c!--ankiQ--\u003e\n\n```tsx\nimport { createSignal, createResource } from \"solid-js\";\nimport { render } from \"solid-js/web\";\n\nconst fetchUser = async (id) =\u003e\n  (await fetch(`https://swapi.dev/api/people/${id}/`)).json();\n\nconst App = () =\u003e {\n  const [userId, setUserId] = createSignal();\n  const [user] = \u003c⚠️ userId가 변경될 시 fetchUser 로 리소스 획득\u003e\n\n  return (\n    \u003c\u003e\n      \u003cinput\n        type=\"number\"\n        min=\"1\"\n        placeholder=\"Enter Numeric Id\"\n        onInput={(e) =\u003e setUserId(e.currentTarget.value)}\n      /\u003e\n      \u003cspan\u003e{\u003c⚠️로딩 동안 표시하도록 작성\u003e \u0026\u0026 \"Loading...\"}\u003c/span\u003e\n      \u003cdiv\u003e\n        \u003cpre\u003e{JSON.stringify(\u003c⚠️유저의 값\u003e, null, 2)}{user.error}\u003c/pre\u003e\n      \u003c/div\u003e\n    \u003c/\u003e\n  );\n};\n\nrender(App, document.getElementById(\"app\"));\n```\n\n위 Solid 코드의 빈칸을 createResource 를 이용하여 수정하라.\n\n\u003c!--ankiA--\u003e\n\n```tsx\nimport { createSignal, createResource } from \"solid-js\";\nimport { render } from \"solid-js/web\";\n\nconst fetchUser = async (id) =\u003e\n  (await fetch(`https://swapi.dev/api/people/${id}/`)).json();\n\nconst App = () =\u003e {\n  const [userId, setUserId] = createSignal();\n  const [user] = createResource(userId, fetchUser);\n\n  return (\n    \u003c\u003e\n      \u003cinput\n        type=\"number\"\n        min=\"1\"\n        placeholder=\"Enter Numeric Id\"\n        onInput={(e) =\u003e setUserId(e.currentTarget.value)}\n      /\u003e\n      \u003cspan\u003e{user.loading \u0026\u0026 \"Loading...\"}\u003c/span\u003e\n      \u003cdiv\u003e\n        \u003cpre\u003e{JSON.stringify(user(), null, 2)}{user.error}\u003c/pre\u003e\n      \u003c/div\u003e\n    \u003c/\u003e\n  );\n};\n\nrender(App, document.getElementById(\"app\"));\n```\n\n\u003c!--ankiE--\u003e\n\u003c!--ID: 1665057833173--\u003e\n","lastmodified":"2022-10-06T14:49:07.154768861Z","tags":null},"/note/SolidJS-Reactivity-Suspense":{"title":"","content":"# SolidJS - Reactivity - Suspense\n\u003c!--Basic Template V0.0.2 Start --\u003e\n```dataview\nTABLE WITHOUT ID  file.link AS title, tags\nFROM -\"templates\"\nSORT file.mtime, tags desc\nWHERE contains(tags, [[]])\n```\n\u003c!--Basic Template V0.0.2 End --\u003e\n[tags::[[SolidJS]]]\n\nhttps://www.solidjs.com/tutorial/async_suspense\n\n`lazy`와 `createResource`를 단독으로 사용할 수 있지만, Solid는 여러 비동기 이벤트 표시를 조정하는 메커니즘도 제공한다, `Suspense`는 이러한 비동기 이벤트가 완료될 때까지 일부 로드된 컨텐츠 대신 fallback 플레이스홀더를 표시할 수 있는 경계 역할을 한다.\n\n이렇게 하면 대량의 로딩 상태로 인한 버벅거림을 제거하여 사용자 경험을 개선할 수 있다. `Suspense`는 하위 비동기 읽기를 자동으로 감지하고 그에 따라 작동한다. 필요한 만큼의 `Suspense` 컴포넌트를 중첩할 수 있으며, `loading` 상태가 변경되면 가장 가까운 상위 항목만 `fallback` 상태로 변환된다.\n\n```tsx\nconst Greeting = lazy(async () =\u003e {\n  // simulate delay\n  await new Promise(r =\u003e setTimeout(r, 1000))\n  return import(\"./greeting\")\n});\n\n...\n\n\u003cGreeting name=\"Jake\" /\u003e\n```\n\nlazy component인 Greeting을 포함하는 JSX 를, Suspense로 로딩 플레이스홀더를 추가하면,\n\n```tsx\n\n...\n\n\u003cSuspense fallback={\u003cp\u003eLoading...\u003c/p\u003e}\u003e\n\t\u003cGreeting name=\"Jake\" /\u003e\n\u003c/Suspense\u003e\n```\n\n와 같이 바꿀 수 있다.\n\n단, `Suspense` 는, Resource 시그널(lazy 컴포넌트 포함)이 읽히지 않으면 정지되지 않는다. 단순히 비동기 fetch 자체를 기다리는 것이 아님에 유의해야 한다.\n\n## 문제\n\nTARGET DECK\n전체::개발::solid\n\n---\n\n\u003c!--ankiQ--\u003e\n\n```tsx\n\u003cGreeting name=\"Jake\" /\u003e\n```\n\n위 Greeting 컴포넌트는 lazy하게 불러온다. 컴포넌트가 로딩되는 동안, Suspense를 이용하여 `\u003cp\u003eLoading...\u003c/p\u003e` 를 대신 출력하려면 어떻게 해야겠는가?\n\n\u003c!--ankiA--\u003e\n\n```tsx\n\u003cSuspense fallback={\u003cp\u003eLoading...\u003c/p\u003e}\u003e\n\t\u003cGreeting name=\"Jake\" /\u003e\n\u003c/Suspense\u003e\n```\n\n\u003c!--ankiE--\u003e\n\u003c!--ID: 1665058595393--\u003e\n","lastmodified":"2022-10-06T14:49:07.154768861Z","tags":null},"/note/SolidJS-Reactivity-Untrack":{"title":"","content":"# SolidJS - Reactivity - Untrack\n\n\u003c!--Basic Template V0.0.2 Start --\u003e\n```dataview\nTABLE WITHOUT ID  file.link AS title, tags\nFROM -\"templates\"\nSORT file.mtime, tags desc\nWHERE contains(tags, [[]])\n```\n\u003c!--Basic Template V0.0.2 End --\u003e\n[tags::[[SolidJS]]]\n\nhttps://www.solidjs.com/tutorial/reactivity_untrack\n\n리액티브 컨텍스트 내에서도 시그널 읽기 작업을 추적하지 않는 것이 필요하다. Solid는 래핑 계산이 읽기 작업을 추적하지 못하도록 하기 위해 untrack이라는 헬퍼를 제공한다.\n\n```tsx\ncreateEffect(() =\u003e {\n\tconsole.log(a(), b());\n});\n```\n\n예제에서 b가 변경되었을 때, 로그를 출력하고 싶지 않다고 가정하자. \n\n```tsx\ncreateEffect(() =\u003e {\n  console.log(a(), untrack(b));\n});\n```\n\n위와 같이 변경하여 b 시그널을 추적 해제할 수 있다.\n\n시그널은 함수이기 때문에 직접 전달할 수 있지만, untrack은 더 복잡한 동작으로 함수를 래핑할 수 있다.\n\nuntrack이 읽기 추적을 비활성화하더라도, 쓰기 작업에는 영향을 미치지 않기 때문에 쓰기 작업은 여전히 추적되고 옵저버에 알림이 가게 된다.\n\n## 문제\n\nTARGET DECK\n전체::개발::solid\n\n---\n\n\u003c!--ankiQ--\u003e\n\n```tsx\ncreateEffect(() =\u003e {\n\tconsole.log(a(), b());\n});\n```\n\n위 이펙트에서 b 에 의한 이펙트는 발생하지 않도록, b 읽기 추적을 비활성화하려면 어떻게 해야 하는가?\n\n\u003c!--ankiA--\u003e\n\n```tsx\ncreateEffect(() =\u003e {\n  console.log(a(), untrack(b));\n});\n```\n\n\u003c!--ankiE--\u003e\n\u003c!--ID: 1665048669559--\u003e\n","lastmodified":"2022-10-06T14:49:07.154768861Z","tags":null},"/note/SolidJS-Router":{"title":"","content":"\u003c!--Basic Template V0.0.2 Start --\u003e\n```dataview\nTABLE WITHOUT ID  file.link AS title, tags\nFROM -\"templates\"\nSORT file.mtime, tags desc\nWHERE contains(tags, [[]])\n```\n\u003c!--Basic Template V0.0.2 End --\u003e\n[tags::[[SolidJS]]]\n\nhttps://github.com/solidjs/solid-router\n\n라우터를 사용하면 브라우저의 URL에 따라 view를 변경할 수 있다. 이것은 \"Single-page\" application이 기존의 멀티 페이지 사이트를 흉내낼 수 있게 한다. 솔리드 라우터를 사용하기 위해서는, URL 값(경로, path)에 의존하는 `Routes` 컴포넌트를 지정해야 하며, 이후 `Router`가 그들을 교체하는 매커니즘을 처리한다.\n\nSolid Router는 SolidJS를 위한, 클라이언트에서 렌더링하든 서버에서 렌더링하든 상관없이 작동하는 범용 라우터다. React 라우터와 Ember 라우터의 패러다임에서 영감을 받아 결합했다. `Routes` 들은 JSX를 이용하여 어플리케이션의 템플릿에서 직접 정의할 수도 있지만, 경로 환경 설정을 Object로 전달할 수도 있다. 중첩 라우팅도 지원하여, 완전히 교체할 필요 없이 일부만 바꿀 수도 있다.\n\nSolid의 모든 SSR 메서드를 지원하며 Solid의 transisions이 탑재되어 있으므로, suspense, resources, lazy components 를 자유롭게 사용할 수 있다. Solid Router로 병렬로 로드되는 데이터 함수를 정의할 수도 있다.\n\n- [[SolidJS - Router - Getting Started]]","lastmodified":"2022-10-06T14:49:07.154768861Z","tags":null},"/note/SolidJS-Router-Getting-Started":{"title":"","content":"## Set Up the Router\n\n## Configure your Routes with JSX\n\n## Configure your Routes with object\n\n\n","lastmodified":"2022-10-06T14:49:07.154768861Z","tags":null},"/note/SolidJS-Stores-Context":{"title":"","content":"# SolidJS - Stores - Context\n\n\u003c!--Basic Template V0.0.2 Start --\u003e\n```dataview\nTABLE WITHOUT ID  file.link AS title, tags\nFROM -\"templates\"\nSORT file.mtime, tags desc\nWHERE contains(tags, [[]])\n```\n\u003c!--Basic Template V0.0.2 End --\u003e\n[tags::[[SolidJS]]]\n\nhttps://www.solidjs.com/tutorial/stores_context\n\nSolid에서 데이터를 다루다 보면, props를 사용하지 않고 전역적으로 데이터를 관리할 필요가 있다. 이럴때 사용하는 것이 Context API다. Context 는 시그널과 스토어를 공유할 때 유용하며, 리액티브 시스템의 일부로 생성되고, 관리된다는 장점이 있다.\n\n```tsx {title=\"counter.jsx\"}\nconst CounterContext = createContext();\n```\n\n먼저 위와 같이 Context 객체를 생성한다.\n\n```tsx {title=\"counter.jsx\"}\n...\nexport function CounterProvider(props) {\n\tconst [count, setCount] = createSignal(props.count || 0);\n}\n```\n\n전역으로 공유하고자 하는 count, setCount 시그널을 생성한다.\n\n```tsx {title=\"counter.jsx\"}\nexport function CounterProvider(props) {\n  const [count, setCount] = createSignal(props.count || 0);\n\n  return (\n    \u003cCounterContext.Provider value={[count, setCount]}\u003e\n      {props.children}\n    \u003c/CounterContext.Provider\u003e\n  );\n}\n```\n\n`createContext` 로 생성한 컨텍스트 객체에는 `Provider` 가 포함되어 있다. 이는 데이터를 주입하는데 사용되는 컴포넌트이므로, 우리가 만든 컨텍스트 컴포넌트의 반환값을 컨텍스트 객체의 Provider로 감싼다.\n\n`CounterProvider`로 App 을 감쌀 것이기 때문에, 반환값 안에 props.children 을 패싱한다.\n\n```tsx {title=\"main.jsx\"}\nimport { render } from \"solid-js/web\";\nimport Nested from \"./nested\";\nimport { CounterProvider } from \"./counter\";\n\nfunction App() {\n  return \u003c\u003e\n    \u003ch1\u003eWelcome to Counter App\u003c/h1\u003e\n    \u003cNested /\u003e\n  \u003c/\u003e\n};\n\nrender(() =\u003e (\n  \u003cCounterProvider count={1}\u003e\n    \u003cApp /\u003e\n  \u003c/CounterProvider\u003e\n), document.getElementById(\"app\"));\n```\n\n렌더 부분을 `CounterProvider` 로 감싼다. 이제 `CounterProvider` 의 데이터가 App 내부에 주입된다.\n\n주입된 데이터를 사용하기 위해서는, 컨텍스트 객체로부터 useContext 컨슈머를 import 해야 한다.\n\n```tsx {title=\"counter.jsx\"}\nimport { createSignal, createContext, useContext } from \"solid-js\";\n\nconst CounterContext = createContext();\n\nexport function CounterProvider(props) {\n  const [count, setCount] = createSignal(props.count || 0);\n\n  return (\n    \u003cCounterContext.Provider value={[count, setCount]}\u003e\n      {props.children}\n    \u003c/CounterContext.Provider\u003e\n  );\n}\n//여기 아래\nexport function useCounter() { return useContext(CounterContext); }\n```\n\n위와 같이 컨텍스트 객체의 컨슈머를 export 하고,\n\n```jsx {title=\"nested.jsx\"}\nimport { useCounter } from \"./counter\";\n\nexport default function Nested() {\n  const [count, setCount] = useCounter();\n  return (\n    \u003c\u003e\n      \u003cdiv\u003e{count()}\u003c/div\u003e\n      \u003cbutton onClick={() =\u003e setCount(count()+1)}\u003e+\u003c/button\u003e\n      \u003cbutton onClick={() =\u003e setCount(count()-1)}\u003e-\u003c/button\u003e\n    \u003c/\u003e\n  );\n};\n```\n\n컨텍스트를 사용할 곳에서는 컨슈머를 import하여 사용한다. `useCounter` 호출 시 Provider 컴포넌트의 value로 지정했던 데이터를 얻을 수 있다.\n\n## 문제\n\nTARGET DECK\n전체::개발::solid\n\n---\n\n\u003c!--ankiQ--\u003e\n\ncounter.jsx\n```tsx {title=\"counter.jsx\"}\nimport { createSignal } from \"solid-js\";\n\nexport function CounterProvider(props) {\n  const [count, setCount] = createSignal(props.count || 0);\n\n  return (\n\t\t{props.children}\n  );\n}\n```\n\napp.jsx\n```tsx {title=\"main.jsx\"}\nimport { render } from \"solid-js/web\";\nimport { CounterProvider } from \"./counter\";\n\nfunction App() {\n\t//이 곳에서 count와 setCount를 쓰고 싶다!\n  return \u003c\u003e\n    \u003ch1\u003eWelcome to Counter App\u003c/h1\u003e\n  \u003c/\u003e\n};\n\nrender(() =\u003e (\n\t\u003cApp /\u003e\n), document.getElementById(\"app\"));\n```\n\ncounter.jsx의 count, setCount 시그널을 전역으로 공유하고 싶다.\n\nContext를 이용하여 위 코드를 수정하라.\n\n\u003c!--ankiA--\u003e\n\ncounter.jsx\n```tsx {title=\"counter.jsx\"}\nimport { createSignal, createContext, useContext } from \"solid-js\"; //1\n\nconst CounterContext = createContext(); //2\n\nexport function CounterProvider(props) {\n  const [count, setCount] = createSignal(props.count || 0);\n\n  return (\n    \u003cCounterContext.Provider value={[count, setCount]}\u003e //3\n      {props.children}\n    \u003c/CounterContext.Provider\u003e\n  );\n}\n//여기 아래\nexport function useCounter() { return useContext(CounterContext); }\n```\n\n1. solid-js 에서 createContext, useContext import\n2. 최상위에서 Context 객체 생성\n3. 컨텍스트 객체의 Provider로 반환값 감싸고 value 지정\n4. useContext export\n\napp.jsx\n```tsx {title=\"main.jsx\"}\nimport { render } from \"solid-js/web\";\nimport Nested from \"./nested\";\nimport { CounterProvider, useCounter } from \"./counter\"; //1\n\nfunction App() {\n  const [count, setCount] = useCounter(); //2\n  return \u003c\u003e\n    \u003ch1\u003eWelcome to Counter App\u003c/h1\u003e\n  \u003c/\u003e\n};\n\nrender(() =\u003e (\n  \u003cCounterProvider count={1}\u003e //3\n    \u003cApp /\u003e\n  \u003c/CounterProvider\u003e\n), document.getElementById(\"app\"));\n```\n\n1. 커스텀 컨텍스트로부터 useCounter import\n2. useCounter로 컨텍스트 value 획득\n3. CounterProvider로 app을 감싼다\n\n\u003c!--ankiE--\u003e\n\u003c!--ID: 1665044963832--\u003e\n","lastmodified":"2022-10-06T14:49:07.154768861Z","tags":null},"/note/SolidJS-Stores-Create-Store":{"title":"","content":"# SolidJS - Stores - Create Store\n\n\u003c!--Basic Template V0.0.2 Start --\u003e\n```dataview\nTABLE WITHOUT ID  file.link AS title, tags\nFROM -\"templates\"\nSORT file.mtime, tags desc\nWHERE contains(tags, [[]])\n```\n\u003c!--Basic Template V0.0.2 End --\u003e\n[tags::[[SolidJS]]]\n\nhttps://www.solidjs.com/tutorial/stores_createstore\n\n저장소 생성\n\n중첩된 반응성에 대한 Solid의 대답은 Store 다. Store는 프록시 객체[^프록시]이며, 프록시 내부의 프로퍼티를 추적할 수 있으며 프록시 내부에 자동으로 래핑되는 다른 객체들을 포함한다.\n\n\n[^프록시]: 객체를 감싸는 객체로, 객체에 가해지는 작업(읽기, 쓰기 등)을 가로채서 사전 정의된 행동을 한다. \n\nSignal이 하나의 반응성 값을 다룬다면, Store는 주로 반응성 값들의 collection을 다루는데 사용한다. object나 array 가 있겠다.\n\nStore를 가볍게 유지하기 위해, Solid는 추적 범위 내에서 접근하는 프로퍼티에 대해서만 내부적으로 시그널을 생성한다. 즉 스토어의 모든 시그널들은 필요시에만 지연 생성된다.\n\n```tsx\nconst [todos, setTodos] = createSignal([])\n```\n\ncreateStore 함수 호출시 초기값을 인자로 받아서, 시그널과 비슷하게 읽기/쓰기 튜플을 반환한다. 첫번째 항목은 읽기 전용 스토어 프록시이며, 두 번째 항목은 setter 함수이다.\n\nsetter 함수의 가장 기본적인 형식은 인자로 객체를 받으며, 받은 객체의 프로퍼티를 현재 상태에 머지한다. 또한 중첩된 업데이트를 할 수 있도록 path syntax도 지원한다.\n\n이러한 방법으로 반응성에 대한 제어를 유지하면서도 원하는 부분만 선택해 업데이트할 수 있게 되었다.\n\n\u003e Solid의 Path Syntax에는 많은 형식이 있으며, 반복과 범위를 위한 강력한 구문도 포함하고 있다. 전체 레퍼런스를 보려면 [API 문서](https://www.solidjs.com/docs/latest/api#updating-stores)를 참고.\n\n```tsx\n  const [todos, setTodos] = createSignal([])\n  const addTodo = (text) =\u003e {\n    setTodos([...todos(), { id: ++todoId, text, completed: false }]);\n  }\n  const toggleTodo = (id) =\u003e {\n    setTodos(todos().map((todo) =\u003e (\n      todo.id !== id ? todo : { ...todo, completed: !todo.completed }\n    )));\n  }\n```\n\n위의 코드를 store를 이용해서 개선하면,\n\n```tsx\nconst [todos, setTodos] = createStore([]);\nconst addTodo = (text) =\u003e {\n  setTodos([...todos, { id: ++todoId, text, completed: false }]);\n};\nconst toggleTodo = (id) =\u003e {\n  setTodos(\n    (todo) =\u003e todo.id === id,\n    \"completed\",\n    (completed) =\u003e !completed\n  );\n};\n```\n\n위와 같다.\n\n## 문제\n\nTARGET DECK\n전체::개발::solid\n\n---\n\n\u003c!--ankiQ--\u003e\n\n```tsx\nconst [state, setState] = createStore({\n  counter: 2,\n  list: [\n    { id: 23, title: 'Birds' }\n    { id: 27, title: 'Fish' }\n  ]\n});\n```\n\n위 Solid 코드에서, counter 를 1 증가시키는 코드를 작성하라.\n\n\u003c!--ankiA--\u003e\n\n```tsx\nsetState('counter', c =\u003e c + 1);\n```\n\n\u003c!--ankiE--\u003e\n\u003c!--ID: 1665038687117--\u003e\n\n\n---\n\n\u003c!--ankiQ--\u003e\n\n```tsx\nconst [state, setState] = createStore({\n  counter: 2,\n  list: [\n    { id: 23, title: 'Birds' }\n    { id: 27, title: 'Fish' }\n  ]\n});\n```\n\n위 Solid 코드에서, list에 {id: 43, title: 'Marsupials'} 를 추가하는 코드를 작성하라.\n\n\u003c!--ankiA--\u003e\n\n```tsx\nsetState('list', l =\u003e [...l, {id: 43, title: 'Marsupials'}]);\n```\n\n\u003c!--ankiE--\u003e\n\u003c!--ID: 1665038687160--\u003e\n\n---\n\n\u003c!--ankiQ--\u003e\n\n```tsx\nconst [state, setState] = createStore({\n  counter: 2,\n  list: [\n    { id: 23, title: 'Birds' }\n    { id: 27, title: 'Fish' }\n  ]\n});\n```\n\n위 Solid 코드에서, list의 index 2 (3번째) 요소에 read: true 프로퍼티를 추가하는 코드를 작성하라.\n\n\u003c!--ankiA--\u003e\n\n```tsx\nsetState('list', 2, 'read', true);\n```\n\n\u003c!--ankiE--\u003e\n\u003c!--ID: 1665038687168--\u003e\n\n---\n\n\u003c!--ankiQ--\u003e\n\n```tsx\nconst [state, setState] = createStore({\n  todos: [\n    { task: 'Finish work', completed: false }\n    { task: 'Go grocery shopping', completed: false }\n    { task: 'Make dinner', completed: false }\n  ]\n});\n```\n\n위 Solid 코드에서, todos의 index 0, 2 요소의 completed 를 true로 바꾸는 코드를 작성하라.\n\n\u003c!--ankiA--\u003e\n\n```tsx\nsetState('todos', [0, 2], 'completed', true);\n```\n\n\u003c!--ankiE--\u003e\n\u003c!--ID: 1665038687173--\u003e\n\n---\n\n\u003c!--ankiQ--\u003e\n\n```tsx\nconst [state, setState] = createStore({\n  todos: [\n    { task: 'Finish work', completed: false }\n    { task: 'Go grocery shopping', completed: false }\n    { task: 'Make dinner', completed: false }\n  ]\n});\n```\n\n위 Solid 코드에서, todos의 index 0부터 1까지,  completed 를 토글하는 코드를 작성하라.\n\n\u003c!--ankiA--\u003e\n\n```tsx\nsetState('todos', { from: 0, to: 1 }, 'completed', c =\u003e !c);\n```\n\n\u003c!--ankiE--\u003e\n\u003c!--ID: 1665038687177--\u003e\n\n---\n\n\u003c!--ankiQ--\u003e\n\n```tsx\nconst [state, setState] = createStore({\n  todos: [\n    { task: 'Finish work', completed: false }\n    { task: 'Go grocery shopping', completed: false }\n    { task: 'Make dinner', completed: false }\n  ]\n});\n```\n\n위 Solid 코드에서,  todos 중 completed 가 true인 요소의 task 문자열의 맨 뒤에 '!' 을 추가하는 코드를 작성하라.\n\n\u003c!--ankiA--\u003e\n\n```tsx\nsetState('todos', todo =\u003e todo.completed, 'task', t =\u003e t + '!')\n```\n\n\u003c!--ankiE--\u003e\n\u003c!--ID: 1665038687181--\u003e\n\n---\n\n\u003c!--ankiQ--\u003e\n\n```tsx\nconst [state, setState] = createStore({\n  todos: [\n    { task: 'Finish work', completed: false }\n    { task: 'Go grocery shopping', completed: false }\n    { task: 'Make dinner', completed: false }\n  ]\n});\n```\n\n위 Solid 코드에서, todos의 모든 요소에 marked: true 속성을 추가하는 코드를 작성하라.\n\n\u003c!--ankiA--\u003e\n\n```tsx\nsetState('todos', {}, todo =\u003e ({ marked: true}))\n```\n\n\u003c!--ankiE--\u003e\n\u003c!--ID: 1665038687186--\u003e\n\n---\n\n\u003c!--ankiQ--\u003e\n\n```tsx\nconst [todos, setTodos] = createSignal([])\nconst addTodo = (text) =\u003e {\n\tsetTodos([...todos(), { id: ++todoId, text, completed: false }]);\n}\nconst toggleTodo = (id) =\u003e {\n\tsetTodos(todos().map((todo) =\u003e (\n\t\ttodo.id !== id ? todo : { ...todo, completed: !todo.completed }\n\t)));\n}\n```\n\n위 Solid 코드는 to do 목록을 관리하기 위해 작성되었으나, completed 토글 시 DOM 엘리먼트를 다시 생성해야 하기 때문에 비효율적이다. 이를 Solid의 store 기능을 이용해 개선한다면 어떻게 할 수 있겠는가?\n\n\u003c!--ankiA--\u003e\n\n```tsx\nconst [todos, setTodos] = createStore([]);\nconst addTodo = (text) =\u003e {\n  setTodos([...todos, { id: ++todoId, text, completed: false }]);\n};\nconst toggleTodo = (id) =\u003e {\n  setTodos(\n    (todo) =\u003e todo.id === id,\n    \"completed\",\n    (completed) =\u003e !completed\n  );\n};\n```\n\n\u003c!--ankiE--\u003e\n\u003c!--ID: 1665038687191--\u003e\n","lastmodified":"2022-10-06T14:49:07.154768861Z","tags":null},"/note/SolidJS-Stores-Immutable-Stores":{"title":"","content":"# SolidJS - Stores - Immutable Stores\n\n\u003c!--Basic Template V0.0.2 Start --\u003e\n```dataview\nTABLE WITHOUT ID  file.link AS title, tags\nFROM -\"templates\"\nSORT file.mtime, tags desc\nWHERE contains(tags, [[]])\n```\n\u003c!--Basic Template V0.0.2 End --\u003e\n[tags::[[SolidJS]], [[to do]]]\n\nhttps://www.solidjs.com/tutorial/stores_immutable\n\n저장소는 Solid의 Store 프록시를 사용해 Solid에서 가장 자주 생성된다. 때로는 Redux, Apollo, XState와 같은 변경 불가능한 라이브러리와 인터페이스하고 싶은 경우가 있으며, 이에 대해 세분화된 업데이트를 수행해야 한다.\n\nreconcile 동작. 지금 당장은 이해할 수 없는 내용이라 생략함\n","lastmodified":"2022-10-06T14:49:07.154768861Z","tags":null},"/note/SolidJS-Stores-Mutation":{"title":"","content":"# SolidJS - Stores - Mutation\n\n\u003c!--Basic Template V0.0.2 Start --\u003e\n```dataview\nTABLE WITHOUT ID  file.link AS title, tags\nFROM -\"templates\"\nSORT file.mtime, tags desc\nWHERE contains(tags, [[]])\n```\n\u003c!--Basic Template V0.0.2 End --\u003e\n[tags::[[SolidJS]]]\n\nhttps://www.solidjs.com/tutorial/stores_mutation\n\nSolid는 상태를 업데이트할 때 얕은 불변 패턴을 사용할 것을 강력하게 권장한다. 읽기와 쓰기를 분리함으로써 컴포넌트 계층들을 통과할 때 프록시에 대한 변경 사항을 잃어버릴 위험 없이 시스템의 반응성을 더 잘 컨트롤할 수 있다. 이 점은 시그널에 비해 스토어에서 훨씬 더 증대된다.\n\n하지만 Mutation이 더 추론하기 쉬운 경우도 있다.[^불변성유지] 그렇기 때문에 Solid는 setStore 호출 내에서 Store 객체의 쓰기 가능한 프록시 버전을 수정할 수 있도록 immer[^immer]에서 영감을 받은 produce store 수정 함수를 제공한다.\n\n[^immer]: React용 불변성 관리 라이브러리. https://github.com/immerjs/immer\n\n[^불변성유지]: 데이터가 복잡하면 복잡할 수록 불변성을 유지하면서 상태를 업데이트하기 위한 코드 작성 또한 복잡해지며, 이럴 때 지역적인 Mutation을 사용하면 코드가 훨씬 간결해진다. 함부로 불변성을 깨고 직접 수정하면 프레임워크가 상태 변화를 인식하지 못할 위험성이 있다. 자세한 내용은 우측 참고. [23. Immer 를 사용한 더 쉬운 불변성 관리 · GitBook](https://react.vlpt.us/basic/23-immer.html)\n\n이는 컨트롤을 포기하지 않으면서도 작은 영역의 mutation을 허용하는 좋은 도구이다.\n\n```tsx\nconst [todos, setTodos] = createStore([]);\nconst addTodo = (text) =\u003e {\n  setTodos([...todos, { id: ++todoId, text, completed: false }]);\n};\nconst toggleTodo = (id) =\u003e {\n  setTodos(\n    (todo) =\u003e todo.id === id,\n    \"completed\",\n    (completed) =\u003e !completed\n  );\n};\n```\n\n위의 Todo 예제에서 이벤트 핸들러를 다음과 같이 변경해서 produce를 사용하면,\n\n```tsx\nconst [todos, setTodos] = createStore([]);\n\nconst addTodo = (text) =\u003e {\n  setTodos(\n    produce((todos) =\u003e {\n      todos.push({ id: ++todoId, text, completed: false });\n    })\n  );\n};\nconst toggleTodo = (id) =\u003e {\n  setTodos(\n    (todo) =\u003e todo.id === id,\n    produce((todo) =\u003e (todo.completed = !todo.completed))\n  );\n};\n```\n\n와 같이 바꿀 수 있다.\n\n## 문제\n\nTARGET DECK\n전체::개발::solid\n\n---\n\n\u003c!--ankiQ--\u003e\n\n```tsx\nconst [todos, setTodos] = createStore([]);\nconst addTodo = (text) =\u003e {\n  setTodos([...todos, { id: ++todoId, text, completed: false }]);\n};\nconst toggleTodo = (id) =\u003e {\n  setTodos(\n    (todo) =\u003e todo.id === id,\n    \"completed\",\n    (completed) =\u003e !completed\n  );\n};\n```\n\n위 Solid 코드를 Produce를 이용해 수정하라.\n\n\u003c!--ankiA--\u003e\n\n```tsx\nconst [todos, setTodos] = createStore([]);\n\nconst addTodo = (text) =\u003e {\n  setTodos(\n    produce((todos) =\u003e {\n      todos.push({ id: ++todoId, text, completed: false });\n    })\n  );\n};\nconst toggleTodo = (id) =\u003e {\n  setTodos(\n    (todo) =\u003e todo.id === id,\n    produce((todo) =\u003e (todo.completed = !todo.completed))\n  );\n};\n```\n\n\u003c!--ankiE--\u003e\n\u003c!--ID: 1665040051778--\u003e\n","lastmodified":"2022-10-06T14:49:07.154768861Z","tags":null},"/note/SolidJS-Stores-Nested-Reactivity":{"title":"","content":"# SolidJS - Stores - Nested Reactivity\n\n\u003c!--Basic Template V0.0.2 Start --\u003e\n```dataview\nTABLE WITHOUT ID  file.link AS title, tags\nFROM -\"templates\"\nSORT file.mtime, tags desc\nWHERE contains(tags, [[]])\n```\n\u003c!--Basic Template V0.0.2 End --\u003e\n[tags::[[SolidJS]]]\n\nhttps://www.solidjs.com/tutorial/stores_nested_reactivity\n\n중첩된 반응성\n\nSolid에서 세분화된 반응성을 제공할 수 있는 이유 중 하나는 중첩된 업데이트를 독립적으로 처리할 수 있기 때문이다. 사용자 리스트가 있고, 이 중의 한 사용자 이름을 업데이트한다고 했을 때, Solid는 리스트 자체의 내용을 비교하지 않으면서 DOM 에 있는 이름의 위치만 업데이트한다. UI 프레임워크 중에서 이런 것이 가능한 프레임워크는 거의 없다.\n\n예를 들어, 일반적인 프레임워크에서는 todo를 완료 상태로 설정하기 위해, todo의 복제를 사용해 기존 항목을 교체한다. 리스트를 비교해서 DOM 엘리먼트를 다시 생성해야하기 때문에 비효율적이다.\n\n```tsx\nconst [todos, setTodos] = createSignal([])\nconst addTodo = (text) =\u003e {\n\tsetTodos([...todos(), { id: ++todoId, text, completed: false }]);\n}\n```\n\n```tsx\nconst toggleTodo = (id) =\u003e {\n  setTodos(\n    todos().map((todo) =\u003e (todo.id !== id ? todo : { ...todo, completed: !todo.completed })),\n  );\n};\n```\n\n반면, Solid 는 다음과 같이 중첩된 시그널로 데이터를 초기화한다.\n\n```tsx\nconst [todos, setTodos] = createSignal([])\nconst addTodo = (text) =\u003e {\n  const [completed, setCompleted] = createSignal(false);\n  setTodos([...todos(), { id: ++todoId, text, completed, setCompleted }]);\n};\n```\n\n```tsx\nconst toggleTodo = (id) =\u003e {\n  const index = todos().findIndex((t) =\u003e t.id === id);\n  const todo = todos()[index];\n  if (todo) todo.setCompleted(!todo.completed())\n}\n```\n\n이제 추가 비교 작업 없이, todos 시그널에 추가된 오브젝트의 setCompleted를 호출해서 완료 상태를 업데이트할 수 있다. 이는 복잡한 부분을 뷰에서 데이터로 이동했기 때문에 가능한 것이다. \n\n## 문제\n\nTARGET DECK\n전체::개발::solid\n\n---\n\n\u003c!--ankiQ--\u003e\n\n```tsx\nconst [todos, setTodos] = createSignal([])\nconst addTodo = (text) =\u003e {\n\tsetTodos([...todos(), { id: ++todoId, text, completed: false }]);\n}\nconst toggleTodo = (id) =\u003e {\n\tsetTodos(todos().map((todo) =\u003e (\n\t\ttodo.id !== id ? todo : { ...todo, completed: !todo.completed }\n\t)));\n}\n```\n\n위의 solid 코드는 to do 리스트를 관리하기 위해 작성되었다. 이 코드는 solid 에서 지원하는 기능에 비해 비효율적인데, 이를 어떻게 개선할 수 있는가?\n\n단, 이 문제에서 store는 사용할 수 없다.\n\n\u003c!--ankiA--\u003e\n\n```tsx\nconst [todos, setTodos] = createSignal([])\nconst addTodo = (text) =\u003e {\n\tconst [completed, setCompleted] = createSignal(false); \n\tsetTodos([...todos(), { id: ++todoId, text, completed, setCompleted }]);\n}\nconst toggleTodo = (id) =\u003e {\n\tconst index = todos().findIndex((t) =\u003e t.id === id);\n\tconst todo = todos()[index];\n\tif (todo) todo.setCompleted(!todo.completed())\n}\n```\n\n중첩된 반응성을 사용한다.\n\n질문의 코드는 completed를 토글할 때 DOM 엘리먼트를 다시 생성해야 해서 비효율적이지만, Solid에서는 중첩된 반응성을 제공하기 때문에 목록에 시그널을 집어넣고 수정하는 방식으로 완료 상태를 업데이트할 수 있다.\n\n\u003c!--ankiE--\u003e\n\u003c!--ID: 1665034139955--\u003e\n","lastmodified":"2022-10-06T14:49:07.154768861Z","tags":null},"/note/SolidJS-Stores-Without-Context":{"title":"","content":"# SolidJS - Stores - Without Context\n\n\u003c!--Basic Template V0.0.2 Start --\u003e\n```dataview\nTABLE WITHOUT ID  file.link AS title, tags\nFROM -\"templates\"\nSORT file.mtime, tags desc\nWHERE contains(tags, [[]])\n```\n\u003c!--Basic Template V0.0.2 End --\u003e\n[tags::[[SolidJS]]]\n\nhttps://www.solidjs.com/tutorial/stores_nocontext\n\n컨텍스트 미사용\n\n컨텍스트는 Store를 위한 훌륭한 도구다. 인젝션을 처리하고, 소우권을 리액티브 그래프에 연결하고, 자동으로 할당 해제를 관리하며, Solid의 세분화된 렌더링 덕분에 렌더링 오버헤드가 없다.\n\n때로는 컨텍스트를 사용하는게 너무 과도한 경우가 있으며, 대안은 리액티브 시스템을 직접 사용하는 것이다. 예를 들어, 전역 스코프에 시그널을 생성하고 다른 모듈에서 사용할 수 있도록 export함으로써 전역 리액티브 데이터 스토어를 구축할 수 있다.\n\n```tsx\nimport { createSignal } from 'solid-js';\n\nexport default createSignal(0);\n\n// 다른 소스 파일:\nimport counter from './counter';\nconst [count, setCount] = counter;\n```\n\nSolid의 반응성은 보편적인 개념이다. 이것이 컴포넌트 내부에 있는지 외부에 있는지는 중요하지 않다. 전역 상태 vs 로컬 상태에 대한 별도의 구분은 없으며, 모두 같은 것이다.\n\n유일한 제한 사항은 **모든 계산(이펙트/메모)이 리액티브 루트(createRoot) 아래에 생성**되어야 한다는 점이다. Solid의 render는 이를 자동으로 수행한다.\n\n이 예제에서는 counter.tsx가 전역 Store이다. main.tsx의 컴포넌트를 다음과 같이 수정할 수 있다.\n\n```tsx\nconst { count, doubleCount, increment } = counter;\n\nreturn (\n  \u003cbutton type=\"button\" onClick={increment}\u003e\n    {count()} {doubleCount()}\n  \u003c/button\u003e\n);\n```\n\n따라서 계산을 포함하는 더 복잡한 전역 Store를 사용할 때는 루트를 생성해야 한다.\n\n```tsx\nimport { createSignal, createMemo, createRoot } from \"solid-js\";\n\nfunction createCounter() {\n  const [count, setCount] = createSignal(0);\n  const increment = () =\u003e setCount(count() + 1);\n  const doubleCount = createMemo(() =\u003e count() * 2);\n  return { count, doubleCount, increment };\n}\n\n//export default createCounter;\nexport default createRoot(createCounter);\n```\n\n## 문제\n\nTARGET DECK\n전체::개발::solid\n\n---\n\n\u003c!--ankiQ--\u003e\n\n컨텍스트를 과하게 사용하는 경우가 있고, 이에 대한 대안은 리액티브 시스템을 직접 사용하는 것이다. \n\n```tsx\nimport { createSignal } from 'solid-js';\n\nexport default createSignal(0);\n\n// 다른 소스 파일:\nimport counter from './counter';\nconst [count, setCount] = counter;\n```\n\n위와 같이 전역 스코프에 시그널을 생성하고 export, 다른 모듈에서 import 해서 쓸 수 있다.\n\n이 방식에 제한 사항이 있는데 무엇인가?\n\n\u003c!--ankiA--\u003e\n\n모든 계산(이펙트, 메모)이 리엑티브 루트 아래에 생성되어야 한다.\n\nSolid의 render 에 리액티브 루트를 만드는(`createRoot`) 작업이 포함되어 있어 그 동안은 신경쓰지 않고 작업했지만, 리액티브 시스템을 직접 사용할 때는 이를 신경써야 한다.\n\n```tsx\nimport { createSignal, createMemo, createRoot } from \"solid-js\";\n\nfunction createCounter() {\n  const [count, setCount] = createSignal(0);\n  const increment = () =\u003e setCount(count() + 1);\n  const doubleCount = createMemo(() =\u003e count() * 2);\n  return { count, doubleCount, increment };\n}\n\n//export default createCounter;\nexport default createRoot(createCounter);\n```\n\n위처럼 createRoot로 감싸주면 된다.\n\n\u003c!--ankiE--\u003e\n\u003c!--ID: 1665047073531--\u003e\n","lastmodified":"2022-10-06T14:49:07.154768861Z","tags":null},"/note/Tailwind-CSS":{"title":"","content":"# Tailwind CSS\n\u003c!--Basic Template V0.0.2 Start --\u003e\n```dataview\nTABLE WITHOUT ID  file.link AS title, tags\nFROM -\"templates\"\nSORT file.mtime, tags desc\nWHERE contains(tags, [[]])\n```\n\u003c!--Basic Template V0.0.2 End --\u003e\n[tags::[[to do]]]","lastmodified":"2022-10-06T14:49:07.154768861Z","tags":null},"/note/Typescript":{"title":"","content":"# Typescript\n\u003c!--Basic Template V0.0.2 Start --\u003e\n```dataview\nTABLE WITHOUT ID  file.link AS title, tags\nFROM -\"templates\"\nSORT file.mtime, tags desc\nWHERE contains(tags, [[]])\n```\n\u003c!--Basic Template V0.0.2 End --\u003e\n[tags::[[to do]]]\n\nTARGET DECK\n전체::개발::typescript\n\nhttps://www.typescriptlang.org/\n\n자바스크립트로 빌드하는 강타입 언어.\n\n## 설치 및 실행\n\n일반적으로는, 타입스크립트 `ts` 파일을 자바스크립트 파일로 컴파일하고 그것을 실행하는 방식으로 진행한다.\n\n```bash\nnpm install typescript -D\n```\n\n```bash\nnpx tsc hello.ts\nnode hello.js\n```\n\ntypescript 패키지에는 컴파일러(tsc)가 포함되어있으며 npx tsc 로 ts 파일을 js로 컴파일할 수 있다. (전역으로 설치했다면 npx 안 써도 됨)\n\n\u003c!--ankiQ--\u003e\n\nQ. 타입스크립트의 타입 표기는 프로그램의 런타임 동작을 수정하는가?\n\n\u003c!--ankiA--\u003e\n\nA. 전혀 수정하지 않음.\n\n\u003c!--ankiE--\u003e\n\u003c!--ID: 1664295816662--\u003e\n\n### ts-node\n\n컴파일 한 후 node로 실행하는 것이 번거롭다면 ts-node를 사용해볼 수 있다.\n\nhttps://www.npmjs.com/package/ts-node\n\nts-node는 실행하면서 ts를 js로 즉시 전환해준다. 즉, 위의 tsc -\u003e node 과정을,\n\n```bash\nts-node hello.ts\n```\n\n와 같이 생략할 수 있다.\n\nnodemon과 같이 사용할 수도 있다.[^hannah][^memi-dev] 개발에 사용하면 편리. \n\nts-node-dev 라는 모듈도 있다.[^inpa]\n\n[^hannah]: [[TypeScript] nodemon, ts-node 모듈 설치하기](https://velog.io/@grinding_hannah/TypeScript-nodemon-ts-node-%EB%AA%A8%EB%93%88-%EC%84%A4%EC%B9%98%ED%95%98%EA%B8%B0)\n\n[^memi-dev]: https://www.youtube.com/watch?v=6hz8EX9QhCg `-r tsconfig-paths/register`\n\n[^inpa]:  [[TS] 📘 TypeScript 소개 \u0026 개발 환경 구성하기](https://inpa.tistory.com/entry/TS-%F0%9F%93%98-TypeScript-%EC%86%8C%EA%B0%9C-%EA%B0%9C%EB%B0%9C-%ED%99%98%EA%B2%BD-%EC%84%A4%EC%A0%95-%EC%B4%9D%EC%A0%95%EB%A6%AC-tsconfig)\n\n하지만 컴파일러를 메모리 위에 올려두고 동작하는 특성상 production에서는 사용하지 않는 것이 좋다.[^siner]\n\n[^siner]: [node와 ts-node의 CPU,RAM 사용량 비교](https://blog.siner.io/2022/02/19/node-vs-ts-node/)\n\n### 빌드 툴\n\nhttps://www.typescriptlang.org/docs/handbook/integrating-with-build-tools.html\n\n여러가지 빌드 툴을 이용하여 빌드할 수 있다.\n\n#### Vite\n\nVite는 `.ts` 파일을 즉시 import 하는 것을 지원한다. 단, 타입 확인은 하지 않아 `tsc --noEmit` 등 빌드 과정에서 확인해야 함. [^vite-ts]\n\n또한 TS 컴파일러 옵션 중 `isolatedModules` 가 무조건 `true` 로 설정되어야 한다.\n\n[^vite-ts]: [Features | Vite](https://vitejs.dev/guide/features.html#typescript)\n\n## tsconfig.json\n\n[TypeScript: Documentation - What is a tsconfig.json](https://www.typescriptlang.org/ko/docs/handbook/tsconfig-json.html)\n\n### noImplicitAny\n몇몇 경우 TS는 값의 타입을 추론하지 않고 any로 간주하는데, 위 플래그를 활성화하면 이런 암묵적 any 추론에 대하여 오류를 발생함.\n\n### strictNullChecks\nnull, undefined를 보다 명시적으로 처리. null 혹은 undefined 갑을 참조하는 것을 방지함.\n\n[[TypeScript] strictNullChecks과 Type Guards를 이용한 안전한 코드 | kimhako](https://ohhako.github.io/kimhako/articles/2020-07/Angular-strictNullChecks-post-copy)\n\n## VScode extension\n\n[[VSCode] 💽 TypeScript 코딩하는데 유용한 확장팩 💯 추천](https://inpa.tistory.com/entry/VSCode-%F0%9F%92%BD-TypeScript-%EC%BD%94%EB%94%A9%ED%95%98%EB%8A%94%EB%8D%B0-%EC%9C%A0%EC%9A%A9%ED%95%9C-%ED%99%95%EC%9E%A5%ED%8C%A9-%F0%9F%92%AF-%EC%B6%94%EC%B2%9C)\n\n## 문법\n\n### 타입 추론\n\n```ts\nlet msg = \"hello there!\" //msg: string\n```\n\n값으로부터 추론되는 것들은 굳이 타입 표기를 적지 않는 것이 가장 좋다.\n\n### 변수 타입 지정\n```typescript\nlet name:string = \"aaa\";\n```\n\n```typescript\nlet names:string[] = [\"aaa\", \"bbb\"];\n```\n\n```typescript\nlet name:{firstName:string, middleName?:string, lastName:string} = {firstName:\"Cheolsu\", lastName:\"Kim\"};\n```\n\n#### union type\n\n```typescript\nlet codeNumber:string|number = 123;\n```\n\n#### type alias\n\n```typescript\ntype NewType = string | string[];\nlet varname:NewType = \"value\";\n```\n\n#### interface\n\n```typescript\ninterface User {\n  name: string\n  age: number\n  gender? : string\n  readonly birthYear : number\n  [key:number] : string;\n}\n\nlet user : User = {\n  name : 'xx',\n  age : 30,\n  birthYear : 2000,\n  1 : 'A',\n  2 : 'B'\n}\n```\n\n```typescript\ninterface Add {\n  (num1:number, num2:number): number;\n}\n\nconst add : Add = function(x, y){\n  return x + y;\n}\n```\n\n##### interface extends\n\n```typescript\ninterface Car {\n  color: string;\n}\n  \ninterface Toy {\n  name : string;\n}\n\ninterface ToyCar extends Car, Toy {\n  price: number;\n}\n```\n\n#### function type\n\n```typescript\nfunction makeDouble(x: number) :number{\n  return x*2;\n}\n```\n\n##### Generic\n\n```typescript\nfunction getSize\u003cT\u003e(arr: T[]): number {\n  return arr.length;\n}\n\nconsole.log(getSize([1, 2, 3]));\nconsole.log(getSize\u003cstring\u003e([\"1\", \"2\", \"3\"]));\n```\n\n\n#### Array tuple\n\n```typescript\ntype Member = [number, boolean];\nlet john:Member = [1, true];\n```\n\n#### class\n```typescript\nclass User {\n  name:string;\n  constructor(name:string){\n    this.name = name;\n  }\n}\n```\n\n##### class implements with interface\n\n```typescript\ninterface Car {\n  color: string;\n  wheels: number;\n  start(): void;\n}\n\nclass Bmw implements Car {\n  color: string;wheels = 4;\n  constructor(c: string) {\n    this.color = c;\n  }\n  start() {\n    console.log('go..');\n  }\n}\n```\n\n##### type 전용 imports, exports\n\n\u003c!--ankiQ--\u003e\n\n\"./some-module.js\" 에서 SomeThing 타입만 import 하고 싶은 경우 어떻게 해야 합니까?\n\n\u003c!--ankiA--\u003e\n\n```typescript\nimport type { SomeThing } from \"./some-module.js\";\nexport type { SomeThing };\n```\n\n\u003c!--ankiE--\u003e\n\u003c!--ID: 1664943651422--\u003e\n\n\u003c!--ankiQ--\u003e\n\ntypescript에서, interface와 type alias의 차이점은 무엇입니까?\n\n```typescript\ninterface Point {\n  x: number;\n  y: number;\n}\n```\n\n```typescript\ntype Point = {\n  x: number;\n  y: number;\n};\n```\n\n\u003c!--ankiA--\u003e\n\n1. 오브젝트의 모양을 기술하기 위해 사용될 수 있으나 신택스가 다르다.\n2. 인터페이스와 다르게, type alias는 primitives, union, tuple 에도 사용될 수 있다.\n```typescript\n// primitive\ntype Name = string;\n\n// object\ntype PartialPointX = { x: number; };\ntype PartialPointY = { y: number; };\n\n// union\ntype PartialPoint = PartialPointX | PartialPointY;\n\n// tuple\ntype Data = [number, string];\n```\n3. 확장을 위한 신택스가 다르다.\n```typescript\ninterface PartialPointX { x: number; }\ninterface Point extends PartialPointX { y: number; }\n```\n\n```typescript\ntype PartialPointX = { x: number; };\ntype Point = PartialPointX \u0026 { y: number; };\n```\n\n4. type alias에서 union 사용 시 class implement에 사용할 수 없다. \n```typescript\ntype PartialPoint = { x: number; } | { y: number; };\n\n// FIXME: can not implement a union type\nclass SomePartialPoint implements PartialPoint {\n  x = 1;\n  y = 2;\n}\n```\n\n[Interfaces vs Types in TypeScript - Stack Overflow](https://stackoverflow.com/questions/37233735/interfaces-vs-types-in-typescript)\n\n[TypeScript: Documentation - Everyday Types](https://www.typescriptlang.org/docs/handbook/2/everyday-types.html#differences-between-type-aliases-and-interfaces)\n\n\u003c!--ankiE--\u003e\n\u003c!--ID: 1664295816666--\u003e\n\n## Handbook\n[TypeScript: Handbook - The TypeScript Handbook](https://www.typescriptlang.org/docs/handbook/intro.html)\n\n프로그래밍 커뮤니티에 소개된 지 20년이 지나, 자바스크립트는 가장 널리 퍼진 크로스 플랫폼 언어가 되었다. 웹페이지에 사소한 상호작용을 넣기 위한 작은 스크립팅 언어로 시작하여, 자바스크립트는 규모에 상관없이, 프트엔드든 백엔드든 선택할 수 있는 언어까지 성장했습니다.\n\n\n\n## to do\n\nabstract class\n접근 제한자 (public, private, protected)\n\nhttps://www.typescriptlang.org/docs/handbook/2/narrowing.html\n\nhttps://www.youtube.com/watch?v=17Oh028Jpis\u0026list=PLZKTXPmaJk8KhKQ_BILr1JKCJbR0EGlx0\u0026index=6\n\n유틸리티 타입\n- keyof\n- partial\n- required\n- readonly\n\n## 참고\n\n- https://github.com/basarat/typescript-book\n\t- 타입스크립트 \n- [type-challenges/type-challenges: Collection of TypeScript type challenges with online judge](https://github.com/type-challenges/type-challenges)\n\t- 타입 정의 문제들\n- ","lastmodified":"2022-10-06T14:49:07.154768861Z","tags":null},"/note/Vite":{"title":"","content":"# Vite\n\u003c!--Basic Template V0.0.2 Start --\u003e\n```dataview\nTABLE WITHOUT ID  file.link AS title, tags\nFROM -\"templates\"\nSORT file.mtime, tags desc\nWHERE contains(tags, [[]])\n```\n\u003c!--Basic Template V0.0.2 End --\u003e\n[tags::[[to do]]]\n\n웹팩보다 빠른 프론트엔드 도구.\n\n개발 환경에서는 esbuild를 이용, 배포 환경에서는 rollup을 이용.\n\n대부분의 모던 브라우저가 ESM을 지원한다는 전제 하에 ESM의 장점을 활용함.\n\nhttps://caniuse.com/es6-module-dynamic-import\n\n실제로도 글로벌 브라우저 점유율의 95.86%가 ESM을 지원하므로, vite를 쓰는 것이 문제될 것은 없어 보임.\n\n\n\n\n## 참고\n \n- [Vite 이야기(feat. Svelte) | 요즘IT](https://yozm.wishket.com/magazine/detail/1620/)\n\t- Vite 를 왜 써야 하는지, Vite 도입 배경 등\n- [Webpack → Vite: 번들러 마이그레이션 이야기](https://engineering.ab180.co/stories/webpack-to-vite)\n\t- Webpack-\u003e Vite 마이그레이션\n- [vitejs/awesome-vite: ⚡️ A curated list of awesome things related to Vite.js](https://github.com/vitejs/awesome-vite)\n\t- Vite 관련","lastmodified":"2022-10-06T14:49:07.154768861Z","tags":null},"/note/anki":{"title":"","content":"# anki\n\u003c!--Basic Template V0.0.2 Start --\u003e\n```dataview\nTABLE WITHOUT ID  file.link AS title, tags\nFROM -\"templates\"\nSORT file.mtime, tags desc\nWHERE contains(tags, [[]])\n```\n\u003c!--Basic Template V0.0.2 End --\u003e\n[tags::[[to do]]]\n\n## 사용 플러그인\n\n[AnkiConnect - AnkiWeb](https://ankiweb.net/shared/info/2055492159)\n\n","lastmodified":"2022-10-06T14:49:07.154768861Z","tags":null},"/note/authentication-%EC%9D%B8%EC%A6%9D":{"title":"","content":"# authentication 인증\n","lastmodified":"2022-10-06T14:49:07.154768861Z","tags":null},"/note/authorization-%EC%9D%B8%EA%B0%80":{"title":"","content":"# authorization 인가\n\u003c!--Basic Template V0.0.2 Start --\u003e\n```dataview\nTABLE WITHOUT ID  file.link AS title, tags\nFROM -\"templates\"\nSORT file.mtime, tags desc\nWHERE contains(tags, [[]])\n```\n\u003c!--Basic Template V0.0.2 End --\u003e\n[tags::]","lastmodified":"2022-10-06T14:49:07.154768861Z","tags":null},"/note/blocking-non-blocking-sync-async-%EA%B5%AC%EB%B6%84":{"title":"","content":"# blocking non-blocking sync async 구분\n\u003c!--Basic Template V0.0.2 Start --\u003e\n```dataview\nTABLE WITHOUT ID  file.link AS title, tags\nFROM -\"templates\"\nSORT file.mtime, tags desc\nWHERE contains(tags, [[]])\n```\n\u003c!--Basic Template V0.0.2 End --\u003e\n[tags::[[to do]]]\n\n\n\u003c!--ankiQ--\u003e\nblocking, non-blocking 은 {1:호출되는 함수가 바로 리턴하느냐 마느냐} 가 기준이며, sync, async는 {2:호출되는 함수의 작업 완료 여부를 누가 신경쓰느냐} 가 관심사다.\n\n- blocking: {3:바로 리턴하지 않는다.}\n- non-blocking: {4:바로 리턴한다.}\n- sync: {5:호출되는 함수의 작업 완료 여부를 **호출하는 함수**가 신경쓴다.}\n- async: {6:호출되는 함수의 작업 완료 여부를 **호출되는 함수**가 신경쓴다.}\n\u003c!--ankiE--\u003e\n\u003c!--ID: 1664360756815--\u003e\n","lastmodified":"2022-10-06T14:49:07.154768861Z","tags":null},"/note/cold-start-%EC%BD%9C%EB%93%9C-%EC%8A%A4%ED%83%80%ED%8A%B8":{"title":"","content":"# cold start 콜드 스타트\n\u003c!--Basic Template V0.0.2 Start --\u003e\n```dataview\nTABLE WITHOUT ID  file.link AS title, tags\nFROM -\"templates\"\nSORT file.mtime, tags desc\nWHERE contains(tags, [[]])\n```\n\u003c!--Basic Template V0.0.2 End --\u003e\n[tags::[[to do]]]","lastmodified":"2022-10-06T14:49:07.154768861Z","tags":null},"/note/diary-%EC%9D%BC%EA%B8%B0":{"title":"","content":"# diary 일기\n\u003c!--Basic Template V0.0.2 Start --\u003e\n```dataview\nTABLE WITHOUT ID  file.link AS title, tags\nFROM -\"templates\"\nSORT file.mtime, tags desc\nWHERE contains(tags, [[]])\n```\n\u003c!--Basic Template V0.0.2 End --\u003e\n[tags::[[메인 Main]]]","lastmodified":"2022-10-06T14:49:07.154768861Z","tags":null},"/note/duckduckgo%EB%A5%BC-%EB%8C%80%EC%B2%B4%ED%95%98%EB%8A%94-%EA%B2%80%EC%83%89-%EC%97%94%EC%A7%84":{"title":"","content":"# duckduckgo를 대체하는 검색 엔진\n\u003c!--Basic Template V0.0.2 Start --\u003e\n```dataview\nTABLE WITHOUT ID  file.link AS title, tags\nFROM -\"templates\"\nSORT file.mtime, tags desc\nWHERE contains(tags, [[]])\n```\n\u003c!--Basic Template V0.0.2 End --\u003e\n[tags::[[to do]]]\n\n## 왜 덕덕고를 사용하지 않는가\n\n구글의 SEO 를 노리기만 한 저질 페이지들이 계속 노출되면서 다른 검색 엔진으로 갈아탈 필요성을 느꼈다. 그러던 도중 개인 정보 보호를 내세운 덕덕고를 사용해보았는데, 결론은 덕덕고를 더 이상 사용하지 않기로 했다. 주요 이유는 아래와 같다.\n\n### 검색 퀄리티가 좋지 않음\n\n구글의 검색 SEO가 악용되어 검색 퀄리티가 좋지 않다면, 덕덕고는 SEO 자체가 엉망인 느낌이 들었다. 제대로 된 결과를 띄워주지 않는 경우가 부지기수였고 결국엔 다시 구글로 검색하곤 했다.\n\n### 마이크로소프트\n\n덕덕고 브라우저에서 마이크로소프트 트래커를 허용하는 일이 있었다. 브라우저에서만 허용하는 것이라곤 하지만 이 일로 더 이상 덕덕고를 신뢰하지 못하게 됐다.\n\n## 대안\n\nhttps://www.youtube.com/watch?v=x9q3qPxrTqg\n\n- ","lastmodified":"2022-10-06T14:49:07.154768861Z","tags":null},"/note/git-%EA%B9%83":{"title":"","content":"# git 깃\n\u003c!--Basic Template V0.0.2 Start --\u003e\n```dataview\nTABLE WITHOUT ID  file.link AS title, tags\nFROM -\"templates\"\nSORT file.mtime, tags desc\nWHERE contains(tags, [[]])\n```\n\u003c!--Basic Template V0.0.2 End --\u003e\n[tags::]\n\n- [[특정 브랜치만 pull 하기]]","lastmodified":"2022-10-06T14:49:07.154768861Z","tags":null},"/note/github-%EA%B9%83%ED%97%99":{"title":"","content":"# github 깃헙\n\u003c!--Basic Template V0.0.2 Start --\u003e\n```dataview\nTABLE WITHOUT ID  file.link AS title, tags\nFROM -\"templates\"\nSORT file.mtime, tags desc\nWHERE contains(tags, [[]])\n```\n\u003c!--Basic Template V0.0.2 End --\u003e\n[tags::[[git 깃]]]\n\n- [[Github fork 와 template 의 차이]]","lastmodified":"2022-10-06T14:49:07.154768861Z","tags":null},"/note/github-oauth%EB%A1%9C-%ED%9A%8C%EC%9B%90%EA%B0%80%EC%9E%85-%EB%B0%8F-%EB%A1%9C%EA%B7%B8%EC%9D%B8-%EA%B5%AC%ED%98%84":{"title":"","content":"# github oauth로 회원가입 및 로그인 구현\n\u003c!--Basic Template V0.0.2 Start --\u003e\n```dataview\nTABLE WITHOUT ID  file.link AS title, tags\nFROM -\"templates\"\nSORT file.mtime, tags desc\nWHERE contains(tags, [[]])\n```\n\u003c!--Basic Template V0.0.2 End --\u003e\n[tags::[[oauth]], [[to do]]]\n\npassport를 이용하여 github oauth를 하는 간단한 예시\nhttps://www.youtube.com/watch?v=anZqM4JnZ3o\n\n[[oauth]]\n\n","lastmodified":"2022-10-06T14:49:07.154768861Z","tags":null},"/note/javascript-decorator":{"title":"","content":"# javascript decorator\n\u003c!--Basic Template V0.0.2 Start --\u003e\n```dataview\nTABLE WITHOUT ID  file.link AS title, tags\nFROM -\"templates\"\nSORT file.mtime, tags desc\nWHERE contains(tags, [[]])\n```\n\u003c!--Basic Template V0.0.2 End --\u003e\n[tags::[[to do]]]","lastmodified":"2022-10-06T14:49:07.154768861Z","tags":null},"/note/javascript-reflection":{"title":"","content":"# javascript reflection\n\u003c!--Basic Template V0.0.2 Start --\u003e\n```dataview\nTABLE WITHOUT ID  file.link AS title, tags\nFROM -\"templates\"\nSORT file.mtime, tags desc\nWHERE contains(tags, [[]])\n```\n\u003c!--Basic Template V0.0.2 End --\u003e\n[tags::[[to do]]]","lastmodified":"2022-10-06T14:49:07.154768861Z","tags":null},"/note/jsx":{"title":"","content":"# jsx\n\u003c!--Basic Template V0.0.2 Start --\u003e\n```dataview\nTABLE WITHOUT ID  file.link AS title, tags\nFROM -\"templates\"\nSORT file.mtime, tags desc\nWHERE contains(tags, [[]])\n```\n\u003c!--Basic Template V0.0.2 End --\u003e\n[tags::[[to do]]]\n\n`const element = \u003ch1\u003eHello World!\u003c/h1\u003e`\n\nJavascript XML\n","lastmodified":"2022-10-06T14:49:07.154768861Z","tags":null},"/note/linux":{"title":"","content":"# linux\n\u003c!--Basic Template V0.0.2 Start --\u003e\n```dataview\nTABLE WITHOUT ID  file.link AS title, tags\nFROM -\"templates\"\nSORT file.mtime, tags desc\nWHERE contains(tags, [[]])\n```\n\u003c!--Basic Template V0.0.2 End --\u003e\n[tags::]","lastmodified":"2022-10-06T14:49:07.154768861Z","tags":null},"/note/linux-git-pat-%EB%93%B1%EB%A1%9D":{"title":"","content":"# linux git pat 등록\n\u003c!--Basic Template V0.0.2 Start --\u003e\n```dataview\nTABLE WITHOUT ID  file.link AS title, tags\nFROM -\"templates\"\nSORT file.mtime, tags desc\nWHERE contains(tags, [[]])\n```\n\u003c!--Basic Template V0.0.2 End --\u003e\n[tags::[[git 깃]], [[linux]]]\n\n## 왜\n\n```bash\nsupport for password authentication was removed \n```\n\nprivate repo를 clone하다 보면 위와 같은 오류가 발생한다.\n\n패스워드 인증을 제거하면서 생긴 일인데, 깃헙에서는 대안으로 PAT 를 제공한다.\n\n## PAT\n\nhttps://docs.github.com/en/authentication/keeping-your-account-and-data-secure/creating-a-personal-access-token\n\nPAT를 생성하는 방법은 위 링크를 참고한다. 거의 대부분의 권한을 허용해야 한다.\n\n이후 다시 git clone을 할 때 비밀번호를 물어볼 때 비밀번호 대신 PAT를 입력하면 된다.\n\nhttps://git-scm.com/book/ko/v2/Git-%EB%8F%84%EA%B5%AC-Credential-%EC%A0%80%EC%9E%A5%EC%86%8C\n\n## Credential Helper\n\n매번 PAT를 확인하는건 귀찮으므로 credential.helper를 이용해야 한다.\n\n이후 위 링크를 참고하여 credential.helper를 설정한다.\n\n`git config --global credential.helper 'store --file ~/.git-credentials'` 정도로 적으면 된다. credential 모드는 store로 하며 credentials는 \\~/.git-credentials 에 저장한다는 의미.\n\ncache 모드도 있으나 지정한 시간이 지나면 삭제되는 모드이므로 굳이 써야되나 싶다.\n\n## 후기\n\nPAT도 지정한 크레덴셜 파일에 평문으로 그대로 노출되므로 PAT 관리에 유의해야 한다.","lastmodified":"2022-10-06T14:49:07.154768861Z","tags":null},"/note/npm-vs-yarn":{"title":"","content":"# npm vs yarn\n\u003c!--Basic Template V0.0.2 Start --\u003e\n```dataview\nTABLE WITHOUT ID  file.link AS title, tags\nFROM -\"templates\"\nSORT file.mtime, tags desc\nWHERE contains(tags, [[]])\n```\n\u003c!--Basic Template V0.0.2 End --\u003e\n[tags::[[to do]]]","lastmodified":"2022-10-06T14:49:07.154768861Z","tags":null},"/note/oauth":{"title":"","content":"# oauth\n\u003c!--Basic Template V0.0.2 Start --\u003e\n```dataview\nTABLE WITHOUT ID  file.link AS title, tags\nFROM -\"templates\"\nSORT file.mtime, tags desc\nWHERE contains(tags, [[]])\n```\n\u003c!--Basic Template V0.0.2 End --\u003e\n[tags::[[authorization 인가]]]\n\nOpen Authorization\n\n[RFC 6749: The OAuth 2.0 Authorization Framework](https://www.rfc-editor.org/rfc/rfc6749)\n\n## 개요\n\nOAuth 사용 이전, 사용자들은 기본적으로 아이디와 비밀번호를 이용하여 인증했다.\n\n## 용어 설명\n\n- Resource Owner\n\t- 보호 자원에 접근할 수 있는 엔티티. resource-owner가 사람인 경우, end-user를 뜻한다.\n- Resource Server\n\t- 보호 자원을 호스팅하는 서버. Access Token들을 이용한 보호 자원 요청을 받아들이고 응답할 수 있다.\n- Client\n\t- 보호 자원을 요청하는 애플리케이션.\n- Authorization server\n\t- Resource Owner 임을 인증하고 성공적으로 인가된 후 Client에게 Access Tokens를 발급하는 서버.\n\n본 문서에서는 편의를 위해 Resource Server 와 Authorization server를 구분하지 않음.\n\n- Refresh Token\n\t- Access Token 은 수명이 정해져있다. 수명이 다 될 때마다 사용자에게 요청하는 것은 너무나도 피곤하기 때문에, Refresh Token을 이용하여 Access Token을 재발급한다.\n\t- Access Token을 발급할 때 Refresh Token도 발급한다.\n\t- Client는 Access Token이 유효하지 않아지면, Authorization server에게 refresh token 을 발급하여 새로운 Access Token을 발급받는다. (Refresh Token는 이때 갱신될 수도 있고, 아닐 수도 있다)\n\n## 절차\n\n### 1. 등록\nClient가 Resource Server에 사전 등록을 해야 함.\n\nClient ID, Client Secret, Authorized redirect URIs를 발급 받는다.\n\nSecret은 절대 유출되면 안 된다.\n\n### 2. Resource Owner의 승인\n\nResource Owner가 Client를 거쳐 Resource server의 어떤 작업을 해야되는 상황.\n\nResource Owner가 해당 동작을 할 것임을 Client에게 알리면, (share 버튼을 눌렀다던지)\n\nClient가 Resource server 주소에 client id, scope, redirect uri를 붙인 주소를 Resource Owner에게 제공. (sign with github 같은)\n\nClient는 해당 주소로 접속.\n\nResource server는 받은 client id와 redirect_uri가 자신이 가지고 있는 정보와 일치하는지 확인한 후 같다면 Resource owner에게 scope 에 해당하는 권한을 부여할 것인지 물어본다. (Client 앱이 이러한 내용 or 권한을 요구했는데 허용할 것인가?)\n\nResource Owner가 동의한 경우 Resource server에 해당 Resource Owner가 특정 Scope에 동의하였음을 기록한다.\n\n### 3. Resource Server의 승인\n\nResource server는 Resource owner에게 redirect URI에 파라미터로 authorization code를 붙여 주소를 제공한다.\n\nResource Owner가 해당 Redirect URI로 접속하게 되면 Client는 해당 유저의 code를 알게 된다.\n\nClient는 Resource Server에게 client id, client secret, redirect uri, code 를 파라미터로 붙여 Access Token을 요청한다.\n\n### 4. Access Token 발급\n\nResource Server는 해당 정보들이 유효한지 검증한 후 Access Token을 Client에게 발급한다.\n\nAccess Token 를 가진 Client는 Resource server에게 Access Token을 통해 Resource Owner의 Scope 에 해당하는 정보, 또는 행동을 요청할 수 있게 된다.\n\n\n## Grant Types\n\n### Authorization Code\n\n### PKCE\n\n### Client Credentials\n\n### Device Code\n\n### Refresh Token\n","lastmodified":"2022-10-06T14:49:07.154768861Z","tags":null},"/note/obsidian-%EC%98%B5%EC%8B%9C%EB%94%94%EC%96%B8":{"title":"","content":"# obsidian 옵시디언\n\u003c!--Basic Template V0.0.2 Start --\u003e\n```dataview\nTABLE WITHOUT ID  file.link AS title, tags\nFROM -\"templates\"\nSORT file.mtime, tags desc\nWHERE contains(tags, [[]])\n```\n\u003c!--Basic Template V0.0.2 End --\u003e\n[tags::]\n\n- [[여러 마크다운 파일을 한번에 find and replace 하는 방법]]]\n- [[Obsidian 을 Github Pages로 호스팅하기]]","lastmodified":"2022-10-06T14:49:07.154768861Z","tags":null},"/note/to-do":{"title":"","content":"# to do\n\u003c!--Basic Template V0.0.2 Start --\u003e\n```dataview\nTABLE WITHOUT ID  file.link AS title, tags\nFROM -\"templates\"\nSORT file.mtime, tags desc\nWHERE contains(tags, [[]])\n```\n\u003c!--Basic Template V0.0.2 End --\u003e\n[tags::[[메인 Main]]]","lastmodified":"2022-10-06T14:49:07.154768861Z","tags":null},"/note/ubuntu-smb-mount":{"title":"","content":"# ubuntu smb mount\n\u003c!--Basic Template V0.0.2 Start --\u003e\n```dataview\nTABLE WITHOUT ID  file.link AS title, tags\nFROM -\"templates\"\nSORT file.mtime, tags desc\nWHERE contains(tags, [[]])\n```\n\u003c!--Basic Template V0.0.2 End --\u003e\n[tags::[[linux]]]\n\n```bash\nsudo mount -t cifs -o user=SMB유저이름,vers=2.0,noperm,password=비밀번호 FTP주소 마운트할로컬경로\n```\n\n\n\n[chmod - how do I mount a CIFS share so I can fully control the mounted volume on the client - Unix \u0026 Linux Stack Exchange](https://unix.stackexchange.com/questions/98707/how-do-i-mount-a-cifs-share-so-i-can-fully-control-the-mounted-volume-on-the-cli)\n\n자동 시작을 위해 서비스로 만들었음.\n\n초기엔 와이파이가 연결되지 않아 unreachable 오류가 발생하여 busy wait을 해줌.","lastmodified":"2022-10-06T14:49:07.154768861Z","tags":null}}